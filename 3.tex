\SetTitle{3}{Overview of computatonal complexity}{No energy lost or gained}{reverse}

\section{Overview}

\begin{frame}{Modeling computation}{Turing machines and complexity classes}
\begin{itemize}
    \item A \href{https://en.wikipedia.org/wiki/Turing_machine}{Turing machine}~(TM) is a simple conceptual device that formalizes the state-to-state nature of computation.
    \item Nobody really builds such a machine, but we say that anything that is computable can be computed on a TM.   
    \only<2>{
    \SmallSkip{}
    Well some people do build such machines:
    \begin{itemize}
        \item \href{https://www.youtube.com/watch?v=E3keLeMwfHY}{Using 35mm film}
        \item \href{https://www.youtube.com/watch?v=5_Hj5x6OWTM}{One with a connection to Washington University.}
    \end{itemize}}
    \item<3-> Here we can think of computation as a program we write. \only<3>{We have to make sure the language we use is clear about how many steps a given statement takes.}
    \item<4-> We can then talk about the number of steps it takes to solve a problem of some size~$n$.  You should already be familiar with \href{https://en.wikipedia.org/wiki/Asymptotic_computational_complexity}{asymptotic notation to express complexity}, especially the time an algorithm or problem takes.
\end{itemize}

\OnlyRemark{5}{We will use asymptotic complexity to describe the time and area needed for computation on a quantum computer.}
    
\end{frame}

\begin{frame}{What input provides a given output?}{A common problem to consider}

\TwoColumns{%
\begin{center}

\only<1-2,5->{
\begin{GateBox}{2.5}{1}{1}
\BoxLabel{$f(x)$}
\Input{0}{$x$}
\Output{0}{$y$}

\end{GateBox}
}
\only<3-4>{
\begin{GateBox}{2.5}{1}{1}
\BoxLabel{$f(x)=2x+5$}
\Input{0}{?}
\Output{0}{105}

\end{GateBox}
}

\end{center}
\SmallSkip{}
\begin{itemize}
    \item<1-> What input value for $x$ produces a $y$ of interest?
    \item<2-> If we have the inverse of f we could compute $x=f^{-1}(y)$
    \item<5-> Not all functions are invertible.
    \item<6-> Some functions may take a long time to find (an) $x\ |\ f(x)=y$.
    
\end{itemize}
}{
\only<3-4>{%
\begin{itemize}
    \item<3-> Consider the function \[ f(x)=2x+5\]
    \item<4> We can use algebra to compute $x=50$ when $f(x)=105$.
\end{itemize}
}%
\only<5>{
\begin{itemize}
\item The function
\[ f(x)=x^{2} \] is \emph{not} invertible, because each output has two possible inputs.  
\item
Here, we can easily find an input that matches a given output, but we cannot hope to create a function $f^{-1}(y)$.
\end{itemize}
}
\only<6>{
\begin{itemize}
\item Examples if this include 
\begin{itemize}
    \item \href{https://en.wikipedia.org/wiki/Bitcoin}{Bitcoin}
    \item \href{https://en.wikipedia.org/wiki/SHA-1}{SHA-1}
    \item \href{https://en.wikipedia.org/wiki/MD5}{MD5}
    \item and other similar hash functions
\end{itemize}

\item A famous problem for quantum computing is shown next.
\end{itemize}
}

}
\end{frame}

\section{Hard problems}

\begin{frame}{Famous problem for quantum computing}{Given integer $n$, find integers $p$ and $q$ such that $pq=n$}
\TwoColumns{%

\begin{itemize}
    \item We don't know yet the true difficulty of this problem.
    \item There is currently no polynomial-time algorithm for solving this problem.
\item<5->
As we will study, a quantum computer can solve this problem in polynomial time.
\item<6>{Do you see a 3 digit number embedded in each of the factors?}
\end{itemize}
}{
\begin{itemize}
    \item Can you factor 21 easily into its two prime factors?  \only<2->{$21=7\times 3$}
    \item<3-> How about \[329716591508669867994509609\]
    \item<4-> It is the product of the \href{https://en.wikipedia.org/wiki/Pell_number\#Primes_and_squares}{Pell prime} \[1746860020068409\]
    and the \href{https://en.wikipedia.org/wiki/Wieferich_prime}{Wieferich prime} \[188748146801\]
    
\end{itemize}
}
\end{frame}

\begin{frame}{Needle in an unstructured haystack}{The complexity of unstructured search}
\TwoColumns{%
\begin{itemize}
    \item Consider a Boolean-valued function $f(x)$ over domain \Domain{D}, $\Mag{\Domain{D}}=2^{n}$.
    \item For one special element $\SpecialX{x}\in\Domain{D}$, $f(\SpecialX{x})=\True$.
    \item $\Forall{x \not= \SpecialX{x}}{f(x)=\False{}}$.
    \item<3-> For analysis, let $N=2^{n}$, and we assume \Domain{D} has no structure to guide a search.
\end{itemize}

}{%
\only<2>{%
Some examples:
\begin{itemize}
    \item $n$ two-position switches
    \item A \href{https://en.wikipedia.org/wiki/Combination_lock\#Single-dial_locks}{combination lock} with a dial of integers $1\ldots 2^{n/3}$.
\end{itemize}}%
\only<4->{%
How much time does it take to find \SpecialX{x}?
\begin{itemize}
    \item<4-> Classically the best we can do is $\Theta(N)$, average- and worst-case.
    \item<5-> If we use $p$ processors, this becomes $\Theta(N/p)$, but unless $p$ scales with $N$, the complexity is unimproved.
    \item<6-> As we will study, \href{https://en.wikipedia.org/wiki/Grover\%27s_algorithm}{Grover's algorithm} offers a quantum computing solution taking $\Theta(\sqrt{N})$ time.
\end{itemize}}
}
\OnlyRemark{7}{Consider how \emph{you} would achieve such a bound looking for something.  The quantum world is strange but offers the promise of greater computing power.}
\end{frame}

\begin{frame}{The discrete log problem}{\href{https://en.wikipedia.org/wiki/Diffie\%E2\%80\%93Hellman_key_exchange}{Key exchange protocol} for \href{https://en.wikipedia.org/wiki/HTTPS}{\texttt{https}}}
\TwoColumns{%
Consider the function
\only<1-2>{
\[ y = g^{x} \bmod p \]
}%
\only<3->{
\[ y = 3^{x} \bmod 17 \]
}%
\visible<1-2>{%
for integers $x, y, g, p$.  Typically $p$ is a very large prime.}
\only<2->{
\begin{itemize}
    \item<2-> Consider $g=3$ and $p=17$
    \item<4-> Suppose $y=13$, what is $x$?
    \item<5-> $x=4$ works
\end{itemize}
}
}{%
\begin{itemize}
    \item Who knows what?
    \begin{itemize}
    \item The world knows $g$ and $p$.
    \item $x$ is private
    \item $y$ is public
    \end{itemize}
    \item Computing $y$ from $x$ is easy and efficient.
    \item Computing $x$ given $y$ is considered difficult classically.
\end{itemize}
}
\OnlyRemark{6}{%
The problem of finding $x$ given $y$ is the \href{https://en.wikipedia.org/wiki/Discrete_logarithm}{discrete logarithm} problem.
}
    
\end{frame}

\begin{frame}{Diffie--Hellman key exchange}{Secrecy relies on the apparent difficulty of discrete log.}

\begin{ProtocolDialog}{0.28\textwidth}{0.33\textwidth}{0.37\textwidth}
\All{$g=5$ and $p=23$.}{My secret $a=7$.}{My secret $b=12$.}
\All{Compute $5^{x}\bmod 23$}{I compute $A=5^{a}\bmod 23$.}{I compute $B=5^{b}\bmod 23$.}
\All{}{I publish $A=17$.}{I publish $B=18$.}
\All{Everybody hears:}{$B=18$}{$A=17$.}
\All{}{I compute $B^{a}\bmod 23$.}{I compute $A^{b}\bmod 23$.}
\All{}{I obtain 6.}{I obtain 6.}
\All{They agree!}{We have a shared key $6$.}{We have a shared key $6$.}
\end{ProtocolDialog}
\OnlyRemark{2}{%
It's easy to compute $A$ from $a$ and $B$ from $b$.  There is no known classical algorithm for efficiently computing $a$ given $A$ and $B$.  Alice and Bob share the key but nobody else can compute it efficiently unless they know $a$ or $b$.
}
    
\end{frame}
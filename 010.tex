%%
%%  Are these the topic we want?
%%  Intersperse exercises students do in place
%%  Add resource links to 3blue1brown etc
%%
\SetTitle{1}{Background}{What you need to know}{01}

\section{Classical Logic}

\begin{frame}{Overview of classical logic}
\begin{itemize}
    \item You should be familiar with \href{https://en.wikipedia.org/wiki/Boolean_algebra}{Boolean algebra} but we will review it here.
    \item The two constants
    \begin{itemize}
        \item \Zero{} or \False{}
        \item \One{} or \True{}
    \end{itemize}
    \item We will review functions over those values.
    \item Classical logic uses \emph{bits} that are either \True{} or \False{}.
    \item Quantum logic uses \emph{qubits} that can be in a \emph{superposition} of \Zero{} and \One{}.
    \item We will study how to implement classical logic using quantum gates.
\end{itemize}
    
\end{frame}


\begin{frame}{Boolean functions of one input}
There are only two possible Boolean functions with just one input:
\begin{itemize}
    \item $f(x) = x$, the identity function
    \item $f(x) = \Not{x}$
\end{itemize}
The second function returns the \emph{complement} of the input value.  The operator is typically pronounced \emph{not}, and it is sometimes written $\neg x$.  In this class we prefer \Not{x}.

The truth table for this function is simple:
\begin{center}
\begin{tabular}{c|c}
$x$  & \Not{x} \\
\hline
\Zero{} & \One{} \\
\One{} & \Zero{} \\
\end{tabular}
\end{center}
\Remark{This function is \emph{reversible} and is its own inverse.}
    
\end{frame}

\def\BTable#1#2#3#4#5{%
\begin{center}
\begin{tabular}{cc|c}
$x$ & $y$ & \ensuremath{#1} \\
\hline
\Zero{} & \Zero{} & \ensuremath{#2} \\
\Zero{} & \One{} & \ensuremath{#3} \\
\One{} & \Zero{} & \ensuremath{#4} \\
\One{} & \One{} & \ensuremath{#5} \\
\end{tabular}
\end{center}
}
\begin{frame}{Boolean functions of two inputs}
For two inputs $x$ and $y$, we generally have:
\BTable{f(x,y)}{f(0,0)}{f(0,1)}{f(1,0)}{f(1,1)}
With four possible results, each \Zero{} or \One{}, there are $2^4$ possible tables. That is, 16 possible Boolean functions of two inputs.
\BigSkip{}
Some of those functions should be familiar.
\end{frame}

\begin{frame}{Conjunction and Disjunction}

\TwoColumns{
Conjunction

\BTable{x\wedge y}{0}{0}{0}{1}

The \emph{and} function is \True{} when both of its inputs are \True{}.

\only<2>{
We sometimes juxtapose inputs to imply conjunction:
\[x\wedge y = xy\]}
}{
Disjunction

\BTable{x\vee y}{0}{1}{1}{1}

The \emph{or} function is \True{} when either input is \True{}.

\only<2>{
We sometimes use $+$ as the operator for disjunction:
\[x\vee y = x + y \]}
}
\only<3>{
\Remark{These functions are \emph{not} reversible.  Even if we are given one of the inputs, the other input cannot be deduced from the output.}
}
\end{frame}

\begin{frame}{Exclusive or}{This operation is prevalent in quantum computations}

\BTable{\Xor{x}{y}}{0}{1}{1}{0}

Exclusive-or is what we usually mean in natural language when we say \emph{or}:
\MedSkip{}
\begin{quote}
    I am going to the gym or I am going to sleep.
\end{quote}
We mean we will do one or the other, but not both.
\Remark{
Given the output of this function and one of the inputs, we can deduce the value of the other input:
$\Xor{(\Xor{x}{y})}{x} = y$
}
\end{frame}

\begin{frame}{Universality}{Why is this of interest?}

\only<1>{%
\begin{itemize}
    \item Suppose you want to open a paint store and want to sell paint of any color.
    \item You might think you need to stock each color separately.
    \item This thinking implies stocking thousands, if not millions, of paint cans of different colors.
    \item However, if you stock only \textcolor{Red}{red}, \textcolor{Yellow}{yellow}, and \textcolor{Blue}{blue}, you can create practically any color from those, \href{https://en.wikipedia.org/wiki/Primary_color\#Traditional_red,_yellow,_and_blue_primary_colors}{but not every color}.
    \item You thus obtain (approximate) \emph{universality} of colors by having just those three colors.
\end{itemize}}
\only<2>{%
\begin{itemize}
    \item What components do we need to create a classical Boolean circuit?  We look at that next.
    \item This is interesting, because as with colors, it would be helpful to be able to construct anything from as few components as possible.
    \item For quantum computing, there is an \href{https://en.wikipedia.org/wiki/Uncountable_set}{uncountably infinite} number of possible gates.
    \item If we start now and build one such gate a second, there are some gates we will \emph{never} build, even given an unbounded amount of time.
    \item So universality for quantum circuits seems harder.  It turns out we can successfully approximate any quantum gate using very few components.  We study this later.
\end{itemize}}
    
\end{frame}

\begin{frame}{Universality}{Theoretically, what operators are needed at a minimum?}
\TwoColumns{
Consider again a general Boolean function of two inputs:
}{
\mbox{}\vskip -3em\mbox{}
\BTable{f(x,y)}{\alert<2>{r_{00}}}{\alert<3>{r_{01}}}{\alert<4>{r_{10}}}{\alert<5>{r_{11}}}
}
\MedSkip{}
Any of the 16 possible functions can be written as:
\[
f(x,y) = \visible<2->{\Not{x}\Not{y}\,r_{00}}\visible<3->{ +\Not{x}y \,r_{01} }\visible<4->{+ x\Not{y}\, r_{10} }\visible<5->{+xy \,r_{11} }
\]
For any $x,y$, exactly one of the above conjunctions involving $x$ and $y$ is true.  Thus, the above expression remains the same if $+$ is replaced by $\oplus$.  
\MedSkip{}
Based on the above, we see that universality is achieved using the three operators $\wedge$, $\vee$, $\neg$.
\end{frame}



\begin{frame}{Can we do better?}{Nand is a universal gate all by itself}
\TwoUnequalColumns{0.6\textwidth}{0.4\textwidth}{%
We define Nand as the not-of-and-of its two inputs:
\[ \Nand{x}{y} = \Not{xy} \]
}{%
\mbox{}\vskip -3.5em\mbox{}\BTable{\Nand{x}{y}}{1}{1}{1}{0}
}
\visible<2->{
\MedSkip{}
From this, we can compute the three operations that provide universality:
\begin{eqnarray*}
\Not{x} & = & \Nand{x}{1} \\
\And{x}{y} & = & \Not{\Nand{x}{y}} \\
\visible<3->{
\Or{x}{y} & = & \Nand{\Not{x}}{\Not{y}}}
\end{eqnarray*}
}
\visible<3->{
The last one follows from one of \href{https://en.wikipedia.org/wiki/De_Morgan\%27s_laws}{De~Morgan's laws}:
\[
\Not{uw} = \Or{\Not{u}}{\Not{w}}
\]
}
\visible<4->{
We can thus achieve universality with only a Nand gate.
}

\end{frame}

\begin{frame}{Comments on universality}{Especially for quantum computing}

\begin{itemize}
    \item<1-> \href{https://en.wikipedia.org/wiki/Logic_gate\#Universal_logic_gates}{Universality} is a \emph{theoretical} concept, examining the interesting question of how to minimize the components needed to construct an arbitrary circuit.
    \item<2-> The difference between theory and practice is that in theory, there is no difference, but in practice, there is. [\,\href{https://www.cse.wustl.edu/~cdgill/}{Prof. Chris Gill}\,]
    \item<3-> In quantum computing, we shall see that the \href{https://en.wikipedia.org/wiki/Toffoli_gate}{Toffoli gate} is universal in quantum computing, because it can realize the Nand function.
    \item<3-> However, gratuitous application of Nand to create arbitrary circuits is inefficient, wasting both qubits and gates.
    \item<3-> Notably, the \href{https://en.wikipedia.org/wiki/Exclusive_or}{exclusive-or} function can be realized directly in a quantum circuit, otherwise consuming some 10 gates and 6 temporary qubits to implement via the Toffoli gate. Qubits are especially precious resources and must be conserved, and every gate operation can introduce noise.
\end{itemize}
    
\end{frame}

\section{Complex arithmetic}

\begin{frame}{Overview of complex arithmetic}
\begin{itemize}
    \item Complex arithmetic is especially convenient for quantum computing.
    \item We will use both forms:
    \begin{itemize}
        \item \href{https://en.wikipedia.org/wiki/Cartesian_coordinate_system}{Cartesian coordinates}
        \item \href{https://en.wikipedia.org/wiki/Polar_coordinate_system}{Polar coordinates}
    \end{itemize}
    \item Complex values allow us to express the magnitude of a wave as well as its phase.  This is helpful for understanding interference.
    \item We could defer using complex arithmetic in this course, but it is wise to embrace it from the start.
\end{itemize}
\end{frame}

\begin{frame}{Complex numbers}{Cartesian coordinates}
  
  \TwoColumns{%
  \begin{itemize}
     \item Each complex number $z$ has a \only<1->{\emph{real}} \only<2->{\emph{and an imaginary}} component.
     \item<3-> Point $z$ is expressed in the usual notation, with $\NiceI=\sqrt{-1}$
     \item<4-> The \emph{conjugate} \Conj{z} of $z$ is obtained by negating its imaginary part.
     
  \end{itemize}
  }{%
    \begin{TIKZP}[scale=0.7]
  \draw[<->] (-1, 0) -- (2.5, 0) node[right] {
    $\Re$ 
  };
  
  \draw (1, 4pt) -- (1, -4pt) node[below] {$a$} ;
  
  \visible<2->{
  \draw[<->] (0, -2.5) -- (0, 2.5) node[above] {$\Im$};
  
  \draw (-4pt, 2) -- (4pt, 2) node[left] {$b\ $} ;
  
  }
  \visible<3->{
  \draw[->] (0, 0) -- (1, 2) ;
  \TZPoint{1.05,2.05}{$z=a+b\NiceI$}{above right}
  
  }
  \visible<4->{
  \draw[->] (0, 0) -- (1, -2) ;
  \TZPoint{1.05,-2.05}{$\Conj{z}=a-b\NiceI$}{below right}
  }
\end{TIKZP}
}
\only<4->{\BigSkip{}The \emph{magnitude} of $z$ is given by $\Mag{z} =  \sqrt{a^{2}+b^{2}}$.}\only<5->{  We thus obtain:
\[
 \Mag{z}^{2}  =  a^{2}+b^{2} = z\Conj{z} = \Conj{z}z
\]
}
\end{frame}

\begin{frame}{The complex unit circle}{All points on the circle have unit length}

\TwoColumns{%
 \begin{itemize}
     \item<1-> The complex unit circle has radius~$1$.
     \item<2-> On the real axis, the circle has intercepts at~\only<2->{$+1$} \only<3->{and~$-1$.}
     \item<4-> On the imaginary axis, the circle has intercepts at~\only<4->{$+\NiceI$} \only<5->{and~$-\NiceI$.}
 \end{itemize}
 }{%
 \begin{TIKZP}[scale=1.3]
    \UnitComplexCircle{}
    \only<2->{\TZPEast{}}
   \only<4->{\TZPNorth{}}
   \visible<3->{\TZPWest{}}
   \only<5->{\TZPSouth{}}
    
 \end{TIKZP}}
 
 \only<5->{
 \BigSkip{}
 We typically express angles in radians in quantum computing, so the circle has $2\pi$ radians.  We proceed around the circle counterclockwise, beginning at point~$+1$.}

\end{frame}


\begin{frame}{From Cartesian to polar coordinates}
\TwoColumns{
\begin{itemize}
    \item<1-> A complex number $z$ as shown to the right is at the Cartesian coordinate
    \[z=\ColorOne{r}(\cos{\ColorTwo{\theta}}+\NiceI\sin{\ColorTwo{\theta}})\]
    \item<2-> From \href{https://en.wikipedia.org/wiki/Euler\%27s_formula}{Euler's formula}, we can write this using reals \ColorOne{$r$} and \ColorTwo{$\theta$} as
    \[ z = \Polar{\ColorOne{r}}{\ColorTwo{\theta}} \]
    
\end{itemize}
    
 }{%
  \begin{TIKZP}[scale=1.2]
    \UnitComplexCircle{}
    \draw[->,ultra thick] (1,0) arc (0:45:1) coordinate (z) ;
    \draw[thick] (0,0) -- (z) ;
    \TZText{0.5,0}{\ColorTwo{$\theta$}}{above}
    \TZText{z}{$z$}{above right}
    \TZText{0.35,0.35}{\ColorOne{$r$}}{above}
    \TZPoint{1,0}{$(\ColorOne{r},0)$}{below right}
 \end{TIKZP}
 }
 \only<3->{
\BigSkip{}The complex number \Polar{\ColorOne{r}}{\ColorTwo{\theta}} can thus be found by starting at $(\ColorOne{r},0)$ and walking counterclockwise around a circle of radius \ColorOne{$r$},
traversing a distance of \ColorTwo{$\theta$} radians along the circle.}
\end{frame}

\begin{frame}{Useful properties of complex numbers}{Multiplication}

Given 
\begin{itemize}
\item $z_{1}=\Polar{\ColorOne{r_{1}}}{\ColorTwo{\theta_{1}}}$  
\item $z_{2}=\Polar{\ColorThree{r_{2}}}{\ColorFour{\theta_{2}}}$
\end{itemize}

The product of these complex numbers is
\begin{align*}
z_{1}z_{2} &= \Polar{\ColorOne{r_{1}}}{\ColorTwo{\theta_1}}\Polar{\ColorThree{r_{2}}}{\ColorFour{\theta_2}}  \\
&= \Polar{\ColorOne{r_{1}}\ColorThree{r_{2}}}{(\ColorTwo{\theta_1}+\ColorFour{\theta_2})}
\end{align*}
\begin{itemize}
    \item The magnitudes multiply
    \item The phases add
\end{itemize}

\end{frame}

\begin{frame}{Useful properties of complex numbers}{Conjugation}

Recall
\Vskip{-3em}\begin{align*}
    \cos(-\theta) &= \cos(\theta) \\
    \sin(-\theta) &= - \sin(\theta)
\end{align*}
Given $z=\Polar{r}{\theta}$, the conjugate of $z$, \Conj{z}, is computed as follows:
\begin{align*}
    \Conj{z} &= \Conj{(\Polar{r}{\theta})} \\
    & = \Conj{r(\cos{\theta}+\NiceI\sin{\theta})} \\
    & = r(\cos{\theta}-\NiceI\sin{\theta}) \\
    &=  r(\cos(-\theta)+\NiceI\sin(-\theta))\\
    \Conj{z} &= \Polar{r}{(-\theta)}
\end{align*}
Conjugating a complex number yields its reflection about the horizontal axis.
\end{frame}





\section{Linear algebra}

\begin{frame}{Overview of linear algebra}{Quantum systems are linear!}
\begin{itemize}
    \item While much of our world behaves nonlinearly, quantum systems can surprisingly be captured using linear algebra.
    \item Vectors and matrices can represent states and gates.  
    \begin{itemize}
        \item The state of a quantum system is most often described as a column vector, called a \href{https://en.wikipedia.org/wiki/Bra-ket_notation}{ket}, such as $\QState{}=\PZero{}$.  More on this notation coming up$\ldots$
         \item The effect of a quantum gate can be described as a square matrix, which maps an input ket to an output ket.
    \end{itemize}
    \item This is convenient but not efficient in the number of quantum bits.
    \begin{itemize}
        \item A vector representing $k$ quantum bits has length $2^{k}$.
        \item A matrix describing a $k$-bit quantum gate has $2^{k} \times 2^{k}$ entries.
    \end{itemize}
    \item The composition of states and gates is computed using \href{https://en.wikipedia.org/wiki/Tensor}{tensor arithmetic}.
\end{itemize}
    
\end{frame}

\begin{frame}{Bra--ket notation}{Describing quantum states}
Quantum computing borrows notation from physics in using \href{https://en.wikipedia.org/wiki/Paul_Dirac}{Paul Dirac}'s \href{https://en.wikipedia.org/wiki/Bra-ket_notation}{bra--ket} notation.
\TwoColumns{%
\begin{itemize}
\item<1-> We typically represent a quantum state using a column vector.


\item<2-> Dirac calls such a vector a \emph{ket}, using this syntax that looks strange, but will soon become useful.


\end{itemize}
}{
\[
\visible<2->{\ket{\psi} = }
\begin{pmatrix}
.578\\ .408\NiceI \\ .319+.253\NiceI \\ -.578

\end{pmatrix}
\]%
\visible<3->{The letter \alert{$\psi$} is typically used in quantum computing to represent \alert{p}state, and especially \alert{p}superpositions.}
}

\only<4->{\BigSkip{} The \emph{bra} of a ket is its conjugate transpose, and \VV{}.
\[
\bra{\psi} =
\begin{pmatrix}
.578 & -.408\NiceI & (.319-.253\NiceI) &  -.578
\end{pmatrix}
\]
}
\end{frame}

\begin{frame}{Kets as state vectors}{A column vector represents a state in quantum computing}

\TwoUnequalColumns{0.85\textwidth}{0.15\textwidth}{%
\Vskip{-3em}\begin{itemize}
    \item<1-> Quantum computing deals greatly with probability distributions among states.
    \item<2-> We use vectors to represent states, with an entry for every possible combination of observable outcomes.
    \item<3-> So, the state of an $n$-qubit system is represented by a vector of $2^n$ entries.  On the right is a $2$-qubit system with~4 combinations of observables \visible<4->{\ColorOne{$00$}}\visible<5->{, \ColorTwo{$01$}}\visible<6->{, \ColorThree{$10$}}\visible<7->{, and~\ColorFour{$11$}.}
    \item<8-> If the vector on the right contained probabilities, we would insist that they sum to~$1$.
    \item<9-> In quantum computing (from \href{https://en.wikipedia.org/wiki/Quantum_mechanics}{quantum mechanics}), the entries are not probabilities. They are \href{https://en.wikipedia.org/wiki/Probability_amplitude}{probability amplitudes}, which can be negative.  The \href{https://en.wikipedia.org/wiki/Square_(algebra)\#Absolute_square}{modulus square} of such a quantity yields the probability of the corresponding observable's outcome.
\end{itemize}%
}{%
\only<3->{%
\[\DQB{\visible<4->{\CFCirc{\RCone}}}{\visible<5->{\CFCirc{\RCtwo}}}{\visible<6->{\CFCirc{\RCthree}}}{\visible<7->{\CFCirc{\RCfour}}}\]
}%
}
\end{frame}

\begin{frame}{Examples of quantum states as kets}{The probability of observing a given basis ket is the magnitude-squared of its amplitude}
\TwoUnequalColumns{0.65\textwidth}{0.35\textwidth}{%
\begin{enumerate}
    \item<1-> $\SQB{1}{0}=\QZero$
    \item<2-> $\SQB{0}{1}=\QOne$
    \item<3-> $\SQB{\RootTwo}{-\RootTwo}=\RootTwo{}\QZero{}-\RootTwo{}\QOne{}$
    
    \item<4-> $\DQB{\RootN{3}}{\RootN{6}}{\RootN{6}}{-\RootN{3}}=\RootN{3}\ket{00}+\RootN{6}\ket{01}+\RootN{6}\ket{10}-\RootN{3}\ket{11}$
\end{enumerate}
}{%
\begin{enumerate}
    \item<1-> A single-qubit state.
    
    Only \QZero{} is possible
    \item<2-> Only \QOne{} is possible.
    \item<3-> \QZero{} and \QOne{} each occurs with probability ${\left(\pm\RootTwo\right)}^2=\frac{1}{2}$
    \item<4-> \ket{00} and \ket{11} occur with probability~$\frac{1}{3}$.  
    
    \ket{01} and \ket{10} occur with probability~$\frac{1}{6}$.
\end{enumerate}
}
\end{frame}



\begin{frame}{Inner Products}
The complete bra--ket of a state \QState{} is the inner product of its bra with the ket, which computes the magnitude of the state, squared:
\Vskip{-2em}\begin{eqnarray*}
\braket{\psi}{\psi} & = &
\begin{pmatrix}
\ColorOne{.578} & \ColorTwo{-.408\NiceI} & \ColorThree{(.319-.253\NiceI)} &  \ColorFour{-.578}
\end{pmatrix}
\times\begin{pmatrix}
\ColorOne{.578}\\ \ColorTwo{.408\NiceI} \\ \ColorThree{.319+.253\NiceI} \\ \ColorFour{-.578}
\end{pmatrix}
\\
 & = & \visible<2->{\ColorOne{.578^{2}}}  \visible<3->{\ColorTwo{-(.408\NiceI)^{2}}} \visible<4->{\ColorThree{+ (.102-.064\NiceI^{2})}} \visible<5->{\ColorFour{+ .578^{2}}} \\
\visible<6->{ & = & \Prob{\QState{}}}\visible<7->{= 1}
\end{eqnarray*}%
\visible<7->{%
For a state~\QState{} that arises in a quantum system,  the above expression is expected to be~$1$.}\visible<8->{  The magnitude-squared of each component is the probability of observing its corresponding bit pattern on measurement.}\visible<9->{  In this example, we would see~\ColorOne{\ket{00}} or~\ColorFour{\ket{11}} with probability $\frac{1}{3}$}\visible<10->{, and see~\ColorTwo{\ket{01}} or~\ColorThree{\ket{10}} with probability $\frac{1}{6}$.}
\end{frame}

\section{Binary notation}

\begin{frame}{Binary integers}{We use bit strings and integers interchangeably}
\begin{itemize}
    \item Although you have seen the notation in your previous studies, good advice is to review \href{https://en.wikipedia.org/wiki/Binary_number}{binary numbers}.
    \item The \emph{computational basis} of quantum computing for an $n$~qubit system consists of states denoted by every binary string (bit string) of $n$ bits.
    \item In quantum computing, these basis states are written as kets as seen above.  Thus, a $3$-qubit system has the computational basis:
    \[ \ket{000}, \ket{001}, \ket{010}, \ket{011}, \ket{100}, \ket{101}, \ket{110}, \ket{111} \]
    which can also be expressed with decimal numerals:
    \[ \ket{0}, \ket{1}, \ket{2}, \ket{3}, \ket{4}, \ket{5}, \ket{6}, \ket{7} \]
\end{itemize}
    
\end{frame}

\begin{frame}{Binary fractions}{We need these as well}
\begin{itemize}
    \item When studying \href{https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm}{phase estimation}, we will make use of \emph{binary fractions}.
    \item These follow the \href{https://en.wikipedia.org/wiki/Positional_notation}{positional number system}, but using bits after a \emph{binary point}.
    \item If the bit string after the integer is $k$ long, we can multiply the value by~$2^k$ and divide by~$2^k$ to interpret the string as its integer value divided by $2^k$.
    \item For example, with $k=3$, the binary fraction $.101$ is $\frac{5}{8}$.
\end{itemize}
\end{frame}

\section*{Outer products}

\begin{frame}{Outer products}
\begin{itemize}
    \item If we instead multiply a ket--bra pair, we obtain an \href{https://en.wikipedia.org/wiki/Outer_product}{outer product}.
    \item Outer products can be used to generate matrices from vectors.
    \item We look at two such uses of outer products:
    \begin{itemize}
        \item Specifying a gate using outer products, based on the mapping of each basis vector
        \item \ColorFour{Writing an arbitrary matrix as a sum of outer products}
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Outer products of computational-basis vectors}{These generate a useful matrix}
\begin{itemize}[<+->]
    \item Define \bra{i} as a \href{https://en.wikipedia.org/wiki/One-hot}{one-hot} vector, with a~$1$ in entry~$i$ and zeros elsewhere.
    \begin{itemize}
    \item For example, in a 3-qubit system, $\bra{6} = (0\ 0\ 0\ 0\ 0\ 0\ 1\ 0)$.  
    
    \item In binary notation, this state is \bra{110}.\end{itemize}
    \item Define \ket{i} similarly, as the analogous column vector.
    \item Thus, the \emph{inner product} \braket{i}{j} is either~$1$ or~$0$, if $i=j$ or $i\not=j$, respectively.
    \item Because \bra{i} and \ket{j} are one-hot vectors, the outer product \KetBra{\ColorOne{i}}{\ColorTwo{j}} creates a matrix with a~$1$ in row~$i$ and column~$j$.  All other entries are~$0$:
    \[ \KetBra{\ColorOne{2}}{\ColorTwo{3}}=\DQB{0}{0}{\ColorOne{1}}{0}\CDQB{0}{0}{0}{\ColorTwo{1}} =
    \begin{pmatrix*}[r]
    0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\
    0 & 0 & 0 & \textcolor{Purple}{\fbox{1}} \\ 0 & 0 & 0 & 0\end{pmatrix*}\]
    \item \ColorFour{A matrix with entries $m_{\ColorOne{i},\ColorOne{j}}$ can be written as
    \(
    \sum_{\ColorOne{i},\ColorTwo{j}} \ m_{\ColorOne{i},\ColorTwo{j}} \,\ket{\ColorOne{i}}\bra{\ColorTwo{j}} 
    \)}
\end{itemize}
\end{frame}

\begin{frame}{Recalling the behavior of the computational basis}{A basis vector selects a given column or row of a matrix}
\begin{itemize}[<+->]
    
    \item In an $n$-qubit system, an operator $U$ is a $2^{n}\times 2^{n}$ matrix.
    \item Then $U\ket{i}$ returns column $i$ of $U$ by selection in the product.
    \item Example:
    \[ \CNOTMatrix\ket{2} = \CNOTMatrix\DQB{0}{0}{1}{0} = \DQB{0}{0}{0}{1}\]
    \item Similarly, $\bra{i}U$ returns row~$i$ of $U$:
    \[
    \bra{3}\CNOTMatrix = \CDQB{0}{0}{0}{1} \CNOTMatrix = \CDQB{0}{0}{1}{0}
    \]
\end{itemize}
\end{frame}

\begin{frame}{Specifying a gate using outer products}{Based on the notation we have so far}

\begin{itemize}
    \item Recall $U\ColorOne{\ket{i}}$ selects column~$i$ of U.
    \item This is synonymous with how $U$ maps the basis vector $i$.
    \item If we desire $U\ColorOne{\ket{i}}=\QState{i}$, then we can create the appropriate column (with zeros everywhere else) using
    \begin{align*}
    U =& \QState{i}\ColorThree{\bra{i}} \mbox{ so that}\\
    U\ColorOne{\ket{i}} =& \QState{i}\ColorThree{\bra{i}}\ColorOne{\ket{i}} \mbox{ selects column $i$ of $U$}\\
    =& \QState{i}\braket{\ColorThree{i}}{\ColorOne{i}} \\
    =& \QState{i}\times 1 = \QState{i} \mbox{ as desired}
    \end{align*}
    \item The gate $U$ for an $n$-qubit system can then be constructed using 
    \[
   U =  \sum_{i=0}^{2^{n}-1}\ \KetBra{\QName{i}}{i} \]
\end{itemize}
    
\end{frame}


\begin{frame}{Example specifying a gate using outer products}{The \PauliX{} gate}

Suppose we want to build a quantum \emph{not} gate (Pauli \PauliX):
\begin{itemize}
    \item<2-> \ColorThree{\ket{0}} maps to \ColorOne{\ket{1}}
    \item<3-> \ColorThree{\ket{1}} maps to \ColorTwo{\ket{0}}
\end{itemize}
\visible<4->{A basis bra \ColorThree{\bra{i}} sends the preceding ket} \visible<5->{(below, \ColorOne{\ket{1}}} \visible<6->{and \ColorTwo{\ket{0}})}\visible<7->{ into column \ColorThree{$i$} of a matrix with all other entries $0$.}
\visible<4->{
\[\visible<5->{\ColorOne{\ket{1}}}\visible<4->{\ColorThree{\bra{0}}} + \visible<6,7,9->{\ColorTwo{\ket{0}}}\visible<4->{\ColorThree{\bra{1}}} = 
\visible<5->{\ColorOne{
\begin{pmatrix}
0 \\ 1
\end{pmatrix}}}
\visible<4->{\ColorThree{
\begin{pmatrix}
1 & 0
\end{pmatrix}}}
+
\visible<6,7,9->{\ColorTwo{
\begin{pmatrix}
1 \\ 0
\end{pmatrix}}}
\visible<4-7,9->{\ColorThree{
\begin{pmatrix}
0 & 1
\end{pmatrix}}}
\visible<8->{
= 
\begin{pmatrix}
\ColorOne{0} & 0 \\
\ColorOne{1} & 0
\end{pmatrix}}
\visible<9->{
+
\begin{pmatrix}
0 & \ColorTwo{1} \\
0 & \ColorTwo{0}
\end{pmatrix}}
\visible<10->{
=
\begin{pmatrix}
\ColorOne{0} & \ColorTwo{1} \\
\ColorOne{1} & \ColorTwo{0}
\end{pmatrix}
= \PauliX{}}
\]}
\only<11->{%

That column is then chosen by \ColorThree{\ket{i}} when subjected to the matrix:  $\PauliX(\ColorThree{\ket{0}})=\ColorOne{\ket{1}}$ and $\PauliX(\ColorThree{\ket{1}})=\ColorTwo{\ket{0}}$.}
\end{frame}

\section*{State vectors}

\begin{frame}{State vectors}{A column vector represents a state in quantum computing}

\TwoUnequalColumns{0.85\textwidth}{0.15\textwidth}{%
\Vskip{-3em}\begin{itemize}
    \item<1-> Quantum computing deals greatly with probability distributions among states.
    \item<2-> We use vectors to represent states, with an entry for every possible combination of observable outcomes.
    \item<3-> So, the state of an $n$-qubit system is represented by a vector of $2^n$ entries.  On the right is a $2$-qubit system with~4 combinations of observables \visible<4->{\ColorOne{$00$}}\visible<5->{, \ColorTwo{$01$}}\visible<6->{, \ColorThree{$10$}}\visible<7->{, and~\ColorFour{$11$}.}
    \item<8-> If the vector on the right contained probabilities, we would insist that they sum to~$1$.
    \item<9-> In quantum computing, the entries are not probabilities. They are \href{https://en.wikipedia.org/wiki/Probability_amplitude}{probability amplitudes}, which can be negative.  The \href{https://en.wikipedia.org/wiki/Square_(algebra)\#Absolute_square}{modulus square} of such a quantity yields the probability of the corresponding observable's outcome.
\end{itemize}%
}{%
\only<3->{%
\[\DQB{\visible<4->{\CFCirc{\RCone}}}{\visible<5->{\CFCirc{\RCtwo}}}{\visible<6->{\CFCirc{\RCthree}}}{\visible<7->{\CFCirc{\RCfour}}}\]
}%
}
\end{frame}

\section*{Unit vectors}

\begin{frame}{Unit vectors in quantum computing}{The discipline is based on the $2$-norm}

\TwoUnequalColumns{0.85\textwidth}{0.15\textwidth}{%
\only<1-5>{%
\Vskip{-3.5em}\begin{itemize}
    \item<1-> Consider a general vector shown to the right with $m$ entries.  
    \item<2-> The \href{https://en.wikipedia.org/wiki/Norm_(mathematics)\#p-norm}{$p$-norm} of a vector $v$ is defined as
    \Vskip{-1em}\[
    \PNorm{v}{p} = \left(\sum_{i=1}^{m} \Mag{x_{i}}^p\right)^{1/p}
    \]
    \item<3-> $p=1$ is the \href{https://en.wikipedia.org/wiki/Norm_(mathematics)\#Taxicab_norm_or_Manhattan_norm}{Manhattan norm}, the sum of a vector of distances.
    \item<4-> Quantum computing uses the \href{https://en.wikipedia.org/wiki/Norm_(mathematics)\#Euclidean_norm_of_complex_numbers}{$2$-norm} of a vector, requiring \ColorOne{unit length}:
    \[
    \Implies{\ColorOne{\sqrt{\sum_{i=1}^{m} \Prob{x_i}} = 1}}{\visible<5->{\ColorTwo{\sum_{i=1}^{m} \Prob{x_i}=1}}}
    \]
    \item<5-> With \Prob{x_i} as the probability of outcome~$i$, \ColorTwo{the above} requires that probabilities sum to~$1$.
\end{itemize}}%
}{%
\[
\QQB{x_1}{x_2}{x_3}{\SCirc{}}{\SCirc{}}{\SCirc{}}{\SCirc{}}{x_m}\]
}
\end{frame}

\section*{The 2--norm}

\begin{frame}{More on the $2$--norm}{From Scott Aaronson}

\begin{itemize}
\item 
\href{https://scottaaronson.com/}{Scott Aaronson} has said that much of the wonder of quantum computing can be attributed to its use of the 2-norm.\LinkArrow{https://www.scottaaronson.com/democritus/lec9.html}  That material is included in \href{https://www.amazon.com/Quantum-Computing-since-Democritus-Aaronson/dp/0521199565}{his book}.  

\item To me, he is the \href{https://en.wikipedia.org/wiki/Douglas_Hofstadter}{Douglas Hofstadter} of quantum computing.  I hope you enjoy reading their work as much as I do.
\item 
Let's follow his way of thinking about this \LinkArrow{https://www.scottaaronson.com/democritus/lec9.html} and see where it takes us.  This will take \alert{about 30~minutes}, and here are some helpful notes:
\begin{itemize}
    \item \href{https://en.wikipedia.org/wiki/Andrew_Wiles}{Andrew Wiles} is a mathematician who famously proved \href{https://en.wikipedia.org/wiki/Fermat\%27s_Last_Theorem}{Fermat's last theorem}. While that theorem concerns integer arithmetic, it poetically deals with squaring.
    \item \href{https://en.wikipedia.org/wiki/Raymond_Laflamme}{Ray Laflamme} is a quantum physicist with whom Aaronson \href{https://news.ycombinator.com/item?id=23621425}{worked in 2006} at \href{https://uwaterloo.ca/institute-for-quantum-computing/}{Waterloo's Institute for Quantum Computing}. He is a co-author of \href{https://www.amazon.com/Introduction-Quantum-Computing-Phillip-Kaye/dp/019857049X}{our textbook}.
    \item \href{https://www.linkedin.com/in/ggutoski/}{Gus Gutoski} was a student in Aaronson's course.
\end{itemize}
\item Aaronson's views of the inherent interest in quantum computing are similar to \href{https://mitpress.mit.edu/contributors/richard-j-lipton}{Richard Lipton's}.
\end{itemize}

\end{frame}

\section*{Exercises}

\begin{frame}{Summary}{Background material: (re)acquaint yourself with the math underlying quantum computing}
\begin{itemize}
    \item If you enjoy, love, or appreciate math, you will find quantum computing rewarding to study.
    \item The effects of a quantum algorithm cannot be understood without the mathematical analysis showing how it works.
    \item If you do not (as yet) share this love of math, you may find quantum computing annoying.  However, your desire to study quantum computer may spark a new love of math.
    \item In any case, if you intend to study quantum computing, you should take the time to brush up on this background material.
    \item There is a homework set to help with that.
\end{itemize}
\end{frame}

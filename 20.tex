\SetTitle{20}{Quantum Algorithms}{Introduction}{20}

\begin{frame}{Overview}{What will we study?}

\begin{itemize}[<+->]
    \item We have just seen that quantum systems have an advantage over classical systems for some simple games.
    \item We now study algorithms for which quantum computing has advantages.
    \item We study the \href{https://qiskit.org/textbook/ch-gates/phase-kickback.html}{phase-kickback trick}, which is used for many of the algorithms of interest.
    \item We will look at a sequence of problems, their classical solutions, and their quantum solutions.
    \item Each successive problem is harder for a classical computer to solve.
    \item We study a general technique for unstructured search, \href{https://en.wikipedia.org/wiki/Grover\%27s_algorithm}{Grover's algorithm}.
    \item We learn how to use quantum computers to find the \href{https://en.wikipedia.org/wiki/Periodic_function}{period} of a function.
    \item We learn how to compute the \href{https://en.wikipedia.org/wiki/Quantum_Fourier_transform}{quantum Fourier transform}.
    \item We finish with \href{https://en.wikipedia.org/wiki/Shor\%27s_algorithm}{Shor's famous algorithm} for \href{https://en.wikipedia.org/wiki/Integer_factorization}{factoring} numbers.
\end{itemize}
    
\end{frame}

\begin{frame}{An important note}{Concerning correctness proofs for quantum algorithms}

\begin{itemize}[<+->]
    \item With some classical algorithms, you may be convinced of the algorithm's correctness simply from the code of the algorithm.
    \item You have probably nonetheless been required to write proofs of such algorithms, but you were likely already a believer.
    \item With quantum algorithms, it is the properties of quantum circuits that yield desired results.
    \item It will be difficult to understand by inspection how a quantum circuit works.
    \item Proofs by way of circuit state-analysis are required to understand how and why a given algorithm produces its results.
\end{itemize}
    
\end{frame}

\begin{frame}{Oracles}{A box that provides answers}
\Vskip{-4em}\TwoUnequalColumns{0.7\textwidth}{0.3\textwidth}{%
\begin{itemize}[<+->]
  \item Many of the problems we study will feature an \href{https://qiskit.org/textbook/ch-gates/oracles.html}{oracle}, which is an opaque box that computes some function~$f(x)$ of its input~$x$.
  \item The oracle has the following obligations:
  \begin{itemize}
      \item It must respect any promises it makes.
      \item It must reliably return the evaluation of $f(x)$ for any input $x$ in its domain.
      \item Its computation time must respect stated bounds, for example, \href{https://en.wikipedia.org/wiki/P_(complexity)}{polynomial time}.
      \item The components necessary for implementing $f$ must be available in a quantum circuit.
  \end{itemize}
  \item The oracle's opacity hides some secret, and it is our task to discover that secret, both classically and using quantum computation.
\end{itemize}
}{%
\begin{center}
    \begin{TIKZP}[scale=1.0]
    \draw[color=gray,fill,fill opacity=0.4] (1,-2) rectangle ++(1,2);
    \draw  (1.5,-1) node {$f$};
    \draw[->,thick] (0,-1) -- node[above] {$x$} ++(1,0);
    \draw[->,thick] (2,-1) -- node[above] {$f(x)$} ++(1,0);
    \end{TIKZP}
\end{center}
}
\end{frame}

\begin{frame}{Universal gates}{For combinational logic in quantum circuits}

\TwoColumns{%
\only<1-6>{%
\begin{itemize}[<+->]
    \item Recall that the Nand gate is universal for classical combinational circuits.
    \item The \href{https://en.wikipedia.org/wiki/Toffoli_gate}{Tofolli} or \NamedGate{CCNOT} gate, shown on the right, computes 
    \And{a}{b}.
    \item The \NamedGate{X} gate complements its input.
    \item Verify that the bottom qubit is~\ket{0} iff $a=b=\ket{1}$
    \item Alternatively, the bottom qubit could be initialized to \ket{1} and the \NamedGate{X} gate would then be omitted.
\end{itemize}}%
\only<7-9>{%
\begin{itemize}
  \item<7-> The quantum circuit computes the correct result on classical inputs~\ket{0} and~\ket{1}, 
  \item<8-> It also produces results when an input is a \emph{superposition} of those states.
  \item<9-> Linearity allows us to consider a quantum gate's behavior on inputs in superposition as the sum of the gate applied to the superposition's basis states. 
\end{itemize}}%
\only<10->{%
We explore this idea with the simpler \NamedGate{CNOT} gate:
\BigSkip{}
\adjustbox{valign=t}{\begin{quantikz}
\lstick{$a$} &  \ctrl{1} & \qw & \qw \\
\lstick{$b$} &  \targ{} & \qw & \qw 
\end{quantikz}}
\BigSkip{}
\visible<13->{%
The result
{\small\[
\alpha_{0}\beta_{0}\ket{00} +
  \alpha_{0}\beta_{1}\ket{01} +
  \alpha_{1}\beta_{1}\ket{10} +
  \alpha_{1}\beta_{0}\ket{11}
\]}%
can be an entangled state: it cannot necessarily be written as the tensor product of two one-qubit states.}
}
}{%
\only<1-10>{%
\visible<2->{%
\adjustbox{valign=t}{\begin{quantikz}
\lstick{$a$} &  \ctrl{1} & \qw & \qw \\
\lstick{$b$} &  \ctrl{1} & \qw & \qw  \\
\lstick{\QZero{}} & \targ{}  & \gate{X} & \qw \rstick{$\Not{\And{a}{b}}$}
\end{quantikz}}}
\BigSkip{}
\visible<5->{%
\adjustbox{valign=t}{\begin{quantikz}
\lstick{$a$} &  \ctrl{1} & \qw & \qw \\
\lstick{$b$} &  \ctrl{1} & \qw & \qw  \\
\lstick{\QOne{}} & \targ{}  & \qw & \qw \rstick{$\Not{\And{a}{b}}$}
\end{quantikz}}}
\only<6->{%
\BigSkip{}
We can thus realize a combinational circuit using quantum qubits and gates.}}%
\only<11->{%
\Vskip{-3em}\begin{itemize}
  \item<11-> Consider \CNOT{a}{b} with $a=\alpha_{0}\ket{0}+\alpha_{1}\ket{1}$ and $b=\beta_{0}\ket{0}+\beta_{1}\ket{1}$
  \item<11-> The input is the tensor product
  $\alpha_{0}\beta_{0}\ket{00} +
  \alpha_{0}\beta_{1}\ket{01} +
  \alpha_{1}\beta_{0}\ket{10} +
  \alpha_{1}\beta_{1}\ket{11}
  $
  \item<12-> So we compute {\small
  \[ \CNOTMatrix{}\DQB{\alpha_{0}\beta_{0}}{\alpha_{0}\beta_{1}}{\alpha_{1}\beta_{0}}{\alpha_{1}\beta_{1}}=\DQB{\alpha_{0}\beta_{0}}{\alpha_{0}\beta_{1}}{\alpha_{1}\beta_{1}}{\alpha_{1}\beta_{0}} \]}
\end{itemize}
}
}

\end{frame}

{
\def\V#1#2{\visible<#1->{\textcolor{#2}{\FCirc{0.30}}}}
\begin{frame}{Review of how a matrix sends inputs to outputs}{Linear algebra}

\TwoColumns{%
For a two-qubit system, recall the representation of bases as column vectors:
\begin{center}
    \begin{tabular}{cccc}
    \ket{00} & \ket{01} & \ket{10} & \ket{11} \\
    \textcolor<1->{\RCone}{\DQB{1}{0}{0}{0}} &
     \textcolor<2->{\RCtwo}{\DQB{0}{1}{0}{0}} &
      \textcolor<3->{\RCthree}{\DQB{0}{0}{1}{0}} &
       \textcolor<4->{\RCfour}{\DQB{0}{0}{0}{1}}
     \end{tabular}
\end{center}

Each column is the output produced when give its corresponding input basis vector.
}{%
We can thus think of the unitary matrix in terms of where it sends each of the basis vectors.
\[
\only<1-4>{U = }\begin{pmatrix*}[c]
  \ket{00} & \ket{01} & \ket{10} & \ket{11} \\
  \V{1}{\RCone} & \V{2}{\RCtwo} & \V{3}{\RCthree} & \V{4}{\RCfour} \\
  \V{1}{\RCone} & \V{2}{\RCtwo} & \V{3}{\RCthree} & \V{4}{\RCfour} \\
  \V{1}{\RCone} & \V{2}{\RCtwo} & \V{3}{\RCthree} & \V{4}{\RCfour} \\
  \V{1}{\RCone} & \V{2}{\RCtwo} & \V{3}{\RCthree} & \V{4}{\RCfour} 
\end{pmatrix*}
\only<5>{%
\textcolor{\RCone}{\DQB{1}{0}{0}{0}} = \DQB{\V{5}{\RCone}}{\V{5}{\RCone}}{\V{5}{\RCone}}{\V{5}{\RCone}}}
\only<6>{%
\textcolor{\RCtwo}{\DQB{0}{1}{0}{0}} = \DQB{\V{6}{\RCtwo}}{\V{6}{\RCtwo}}{\V{6}{\RCtwo}}{\V{6}{\RCtwo}}}
\only<7>{%
\textcolor{\RCthree}{\DQB{0}{0}{1}{0}} = \DQB{\V{7}{\RCthree}}{\V{7}{\RCthree}}{\V{7}{\RCthree}}{\V{7}{\RCthree}}}
\only<8>{%
\textcolor{\RCfour}{\DQB{0}{0}{0}{1}} = \DQB{\V{8}{\RCfour}}{\V{8}{\RCfour}}{\V{8}{\RCfour}}{\V{8}{\RCfour}}}
\]
\visible<5-8>{Applying the matrix to a given basis vector extracts the associated column.}
}

    
\end{frame}}

{
\def\V#1#2{\visible<#1->{\CFCirc{#2}}}
\def\VV#1{\DQB{\CFCirc{#1}}{\CFCirc{#1}}{\CFCirc{#1}}{\CFCirc{#1}}}
\begin{frame}{Using outer products}{To construct gates}

\href{https://qiskit.org/textbook/ch-states/single-qubit-gates.html\#1.1-The-X-Gate-}{see this}
We can also write $U$ as the sum of outer products, one term for each basis vector:
\TwoColumns{%
\[
U = \begin{pmatrix*}[c]
  \ket{00} & \ket{01} & \ket{10} & \ket{11} \\
  \V{1}{\RCone} & \V{2}{\RCtwo} & \V{3}{\RCthree} & \V{4}{\RCfour} \\
  \V{1}{\RCone} & \V{2}{\RCtwo} & \V{3}{\RCthree} & \V{4}{\RCfour} \\
  \V{1}{\RCone} & \V{2}{\RCtwo} & \V{3}{\RCthree} & \V{4}{\RCfour} \\
  \V{1}{\RCone} & \V{2}{\RCtwo} & \V{3}{\RCthree} & \V{4}{\RCfour} 
\end{pmatrix*}
\]
\only<1>{%
\[\VV{\RCone}\CDQB{1}{0}{0}{0} =
\begin{pmatrix*}[r]
  \CFCirc{\RCone} & 0 & 0 & 0 \\
  \CFCirc{\RCone} & 0 & 0 & 0 \\
  \CFCirc{\RCone} & 0 & 0 & 0 \\
  \CFCirc{\RCone} & 0 & 0 & 0
  \end{pmatrix*}
  \]
}%
\only<2>{%
\[\VV{\RCtwo}\CDQB{0}{1}{0}{0} =
\begin{pmatrix*}[r]
  0 & \CFCirc{\RCtwo} & 0 & 0  \\
  0 & \CFCirc{\RCtwo} & 0 & 0  \\
  0 & \CFCirc{\RCtwo} & 0 & 0  \\
  0 & \CFCirc{\RCtwo} & 0 & 0
  \end{pmatrix*}
  \]
}%
\only<3>{%
\[\VV{\RCthree}\CDQB{0}{0}{1}{0} =
\begin{pmatrix*}[r]
  0 & 0 & \CFCirc{\RCthree} & 0   \\
  0 & 0 & \CFCirc{\RCthree} & 0   \\
  0 & 0 & \CFCirc{\RCthree} & 0   \\
  0 & 0 & \CFCirc{\RCthree} & 0 
  \end{pmatrix*}
  \]
}%
\only<4>{%
\[\VV{\RCfour}\CDQB{0}{0}{0}{1} =
\begin{pmatrix*}[r]
  0 & 0 & 0 & \CFCirc{\RCfour}    \\
  0 & 0 & 0 & \CFCirc{\RCfour}    \\
  0 & 0 & 0 & \CFCirc{\RCfour}    \\
  0 & 0 & 0 & \CFCirc{\RCfour}  
  \end{pmatrix*}
  \]
}%
\only<5-9>{%
\BigSkip{}
We can express those row vectors as bras.
}
}{%
\begin{align*}
    U & =
      \VV{\RCone} \alt<1-5>{\alert<5>{\CDQB{1}{0}{0}{0}}}{\bra{00}}
      + \visible<2->{\VV{\RCtwo}} \alt<1-6>{\alert<6>{\CDQB{0}{1}{0}{0}}}{\bra{01}} \\
      & + \visible<3->{\VV{\RCthree}} \alt<1-7>{\alert<7>{\CDQB{0}{0}{1}{0}}}{\bra{10}}
      + \visible<4->{\VV{\RCfour}} \alt<1-8>{\alert<8>{\CDQB{0}{0}{0}{1}}}{\bra{11}}
\end{align*}
}
    
\end{frame}}

{
\def\V#1#2#3{%
   \textcolor<#1->{#2}{#3}}
\begin{frame}{Realization of gates using matrices vs. logic}{Matrices grow exponentially in the number of qubits.}
We can formulate a unitary gate using a matrix derived from a truth table such as this.
\only<6->{But these matrices grow exponentially in the number of qubits.}
\TwoColumns{%
\only<1-6>{%
\[
U=\begin{pmatrix*}
  \V{2}{\RCone}{1} & \V{3}{\RCtwo}{0} & \V{4}{\RCthree}{0} & \V{5}{\RCfour}{0} \\
  \V{2}{\RCone}{0} & \V{3}{\RCtwo}{1} & \V{4}{\RCthree}{0} & \V{5}{\RCfour}{0} \\
  \V{2}{\RCone}{0} & \V{3}{\RCtwo}{0} & \V{4}{\RCthree}{0} & \V{5}{\RCfour}{1} \\
  \V{2}{\RCone}{0} & \V{3}{\RCtwo}{0} & \V{4}{\RCthree}{1} & \V{5}{\RCfour}{0}
\end{pmatrix*}
\]}%
\only<6>{%
\BigSkip{}
This unitary matrix is the familiar \NamedGate{CNOT} gate.  We can arrive at this solution more directly, without having to compute the above matrix.
}
\only<7->{%
\begin{itemize}
    \item<7-> Inspection of the table shows that $x$ is copied, input to output.
    \item<8-> When \alert<8>{$x=0$}, \textcolor<8>{\RCtwo}{$y$ is copied to output}.
    \item<9-> When \alert<9-10>{$x=1$}, \textcolor<10>{\RCtwo}{$y$ is flipped on output}.
\end{itemize}
}
\only<11>{%
\begin{center}
\adjustbox{valign=t}{\begin{quantikz}
\lstick{\ket{x}} &  \ctrl{1} & \qw \rstick{\ket{x}} \\
\lstick{\ket{y}} &  \targ{} & \qw \rstick{\ket{y}}
\end{quantikz}}\end{center}
}%
\only<2>{%
\[
\textcolor{\RCone}{%
\DQB{1}{0}{0}{0}\mapsto \DQB{1}{0}{0}{0}
}
\]
}
\only<3>{%
\[
\textcolor{\RCtwo}{%
\DQB{0}{1}{0}{0}\mapsto \DQB{0}{1}{0}{0}
}
\]
}
\only<4>{%
\[
\textcolor{\RCthree}{%
\DQB{0}{0}{1}{0}\mapsto \DQB{1}{0}{0}{1}
}
\]
}
\only<5>{%
\[
\textcolor{\RCfour}{%
\DQB{0}{0}{0}{1}\mapsto \DQB{0}{0}{1}{0}
}
\]
}
}{%
\begin{center}
\begin{UTable}{$U$}{\alert<7>{$x$}}{$y$}{}{\alert<7>{$x$}}{$y$}
\URow{\visible<2>{\CFCirc{\RCone}}}{\alert<8>{0}}{\textcolor<8>{\RCtwo}{0}}{}{0}{\textcolor<8>{\RCtwo}{0}}
\URow{\visible<3>{\CFCirc{\RCtwo}}}{\alert<8>{0}}{\textcolor<8>{\RCtwo}{1}}{}{0}{\textcolor<8>{\RCtwo}{1}}
\URow{\visible<4>{\CFCirc{\RCthree}}}{\alert<9>{1}}{\textcolor<10>{\RCtwo}{0}}{}{1}{\textcolor<10>{\RCtwo}{1}}
\URow{\visible<5>{\CFCirc{\RCfour}}}{\alert<9>{1}}{\textcolor<10>{\RCtwo}{1}}{}{1}{\textcolor<10>{\RCtwo}{0}}
\end{UTable}\end{center}
\begin{center}
\begin{GateBox}[scale=1.0]{2}{1}{2}
\BoxLabel{U?}
\Input{0}{$x$}
\Input{1}{$y$}
\Output{0}{$x$}
\Output{1}{$y$}
\end{GateBox}
\end{center}
    }
\end{frame}
}
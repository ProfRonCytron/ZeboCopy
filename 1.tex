\SetTitle{1}{Background}{What you need to know}{lec:background}

\section{Classical Logic}

\begin{frame}{Overview of classical logic}
\begin{itemize}
    \item You should be familiar with \href{https://en.wikipedia.org/wiki/Boolean_algebra}{Boolean algebra} but we will review it here.
    \item The two constants
    \begin{itemize}
        \item \Zero{} or \False{}
        \item \One{} or \True{}
    \end{itemize}
    \item We will review functions over those values.
    \item Classical logic uses \emph{bits} that are either \True{} or \False{}.
    \item Quantum logic uses \emph{qubits} that can be in a \emph{superposition} of \Zero{} and \One{}.
    \item We will study how to implement classical logic using quantum gates.
\end{itemize}
    
\end{frame}


\begin{frame}{Boolean functions of one input}
There are only two possible Boolean functions with just one input:
\begin{itemize}
    \item $f(x) = x$, the identity function
    \item $f(x) = \Not{x}$
\end{itemize}
The second function returns the \emph{complement} of the input value.  The operator is typically pronounced \emph{not}, and it is sometimes written $\neg x$.  In this class we prefer \Not{x}.

The truth table for this function is simple:
\begin{center}
\begin{tabular}{c|c}
$x$  & \Not{x} \\
\hline
\Zero{} & \One{} \\
\One{} & \Zero{} \\
\end{tabular}
\end{center}
\Remark{This function is \emph{reversible} and is its own inverse.}
    
\end{frame}

\def\BTable#1#2#3#4#5{%
\begin{center}
\begin{tabular}{cc|c}
$x$ & $y$ & \ensuremath{#1} \\
\hline
\Zero{} & \Zero{} & \ensuremath{#2} \\
\Zero{} & \One{} & \ensuremath{#3} \\
\One{} & \Zero{} & \ensuremath{#4} \\
\One{} & \One{} & \ensuremath{#5} \\
\end{tabular}
\end{center}
}
\begin{frame}{Boolean functions of two inputs}
For two inputs $x$ and $y$, we generally have:
\BTable{f(x,y)}{f(0,0)}{f(0,1)}{f(1,0)}{f(1,1)}
With four possible results, each \Zero{} or \One{}, there are $2^4$ possible tables. That is, 16 possible Boolean functions of two inputs.
\BigSkip{}
Some of those functions should be familiar.
\end{frame}

\begin{frame}{Conjunction and Disjunction}

\TwoColumns{
Conjunction

\BTable{x\wedge y}{0}{0}{0}{1}

The \emph{and} function is \True{} when both of its inputs are \True{}.

\only<2>{
We sometimes juxtapose inputs to imply conjunction:
\[x\wedge y = xy\]}
}{
Disjunction

\BTable{x\vee y}{0}{1}{1}{1}

The \emph{or} function is \True{} when either input is \True{}.

\only<2>{
We sometimes use $+$ as the operator for disjunction:
\[x\vee y = x + y \]}
}
\only<3>{
\Remark{These functions are \emph{not} reversible.  Even if we are given one of the inputs, the other input cannot necessarily be deduced from the output.}
}
\end{frame}

\begin{frame}{Exclusive or}{This operation is prevalent in quantum computations.}

\BTable{\Xor{x}{y}}{0}{1}{1}{0}

Exclusive-or is what we usually mean in natural language when we say \emph{or}:
\MedSkip{}
\begin{quote}
    I am going to the gym or I am going to sleep.
\end{quote}
We mean we will do one or the other, but not both.
\Remark{
Given the output of this function and one of the inputs, we can infer the value of the other input:
$\Xor{(\Xor{x}{y})}{x} = y$
}
\end{frame}

\begin{frame}{Universality}{What operators are needed at a minimum?}
\TwoColumns{
Consider again a general Boolean function of two inputs:
}{
\mbox{}\vskip -3em\mbox{}
\BTable{f(x,y)}{r_{00}}{r_{01}}{r_{10}}{r_{11}}
}
\MedSkip{}
Any of the 16 possible functions can be written as:
\[
f(x,y) = \Not{x}\Not{y}\,r_{00} +\Not{x}y \,r_{01} + x\Not{y}\, r_{10} +xy \,r_{11} 
\]
For any $x,y$, exactly one of the above conjunctions involving $x$ and $y$ is true.  Thus, the above expression remains the same if $+$ is replaced by $\oplus$.  
\MedSkip{}
Based on the above, we see that universality is achieved using the three operators $\wedge$, $\vee$, $\neg$.
\end{frame}



\begin{frame}{Can we do better?}{Nand is a universal gate all by itself.}
\TwoUnequalColumns{0.6\textwidth}{0.4\textwidth}{%
We define Nand as the not-of-and-of its two inputs:
\[ \mbox{Nand($x$,$y$)} = \Not{xy} \]
}{%
\mbox{}\vskip -3.5em\mbox{}\BTable{\Nand{x}{y}}{1}{1}{1}{0}
}
\only<2->{
\MedSkip{}
From this, we can compute the three operations that provide universality:
\begin{eqnarray*}
\Not{x} & = & \Nand{x}{1} \\
\And{x}{y} & = & \Not{\Nand{x}{y}} \\
\only<3->{
\Or{x}{y} & = & \Nand{\Not{x}}{\Not{y}}}
\end{eqnarray*}
}
\only<3>{
The last one follows from one of \href{https://en.wikipedia.org/wiki/De_Morgan\%27s_laws}{De~Morgan's laws}:
\[
\Not{uw} = \Or{\Not{u}}{\Not{w}}
\]
}
\only<4->{
We can thus achieve universality with only a Nand gate.
}

\end{frame}

\section{Complex arithmetic}

\begin{frame}{Overview of complex arithmetic}
\begin{itemize}
    \item Complex arithmetic is especially convenient for quantum computing.
    \item We will use both forms:
    \begin{itemize}
        \item \href{https://en.wikipedia.org/wiki/Cartesian_coordinate_system}{Cartesian coordinates}
        \item \href{https://en.wikipedia.org/wiki/Polar_coordinate_system}{Polar coordinates}
    \end{itemize}
    \item Complex values allow us to express the magnitude of a wave as well as its phase.  This is helpful for understanding interference.
    \item We could defer using complex arithmetic in this course, but it is wise to embrace it from the start.
\end{itemize}
\end{frame}

\begin{frame}{Complex Numbers}{Cartesian coordinates}
  
  \TwoColumns{%
  \begin{itemize}
     \item Each complex number $z$ has a \only<1->{\emph{real}} \only<2->{\emph{and an imaginary}} component.
     \item<3-> Point $z$ is expressed in the usual notation, with $i=\sqrt{-1}$
     \item<4-> The \emph{conjugate} \Conj{z} of $z$ is obtained by negating its imaginary part.
     
  \end{itemize}
  }{%
    \begin{TIKZP}[scale=0.7]
  \draw[<->] (-1, 0) -- (2.5, 0) node[right] {
    $\Re$ 
  };
  
  \draw (1, 4pt) -- (1, -4pt) node[below] {$a$} ;
  
  \visible<2->{
  \draw[<->] (0, -2.5) -- (0, 2.5) node[above] {$\Im$};
  
  \draw (-4pt, 2) -- (4pt, 2) node[left] {$b\ $} ;
  
  }
  \visible<3->{
  \draw[->] (0, 0) -- (1, 2) ;
  \TZPoint{1.05,2.05}{$z=a+bi$}{above right}
  
  }
  \visible<4->{
  \draw[->] (0, 0) -- (1, -2) ;
  \TZPoint{1.05,-2.05}{$\Conj{z}=a-bi$}{below right}
  }
\end{TIKZP}
}
\only<4->{\BigSkip{}The \emph{magnitude} of $z$ is given by $\Mag{z} =  \sqrt{a^{2}+b^{2}}$.}\only<5->{  We thus obtain:
\[
 \Mag{z}^{2}  =  a^{2}+b^{2} = z\Conj{z} = \Conj{z}z
\]
}
\end{frame}

\begin{frame}{The complex unit circle}{All points on the circle have unit length.}

\TwoColumns{%
 \begin{itemize}
     \item<1-> The unit circle has radius~$1$.
     \item<2-> On the real axis, the circle has intercepts at~\only<2->{$+1$} \only<3->{and~$-1$.}
     \item<4-> On the imaginary axis, the circle has intercepts at~\only<4->{$+i$} \only<5->{and~$-i$.}
 \end{itemize}
 }{%
 \begin{TIKZP}[scale=1.3]
    \UnitComplexCircle{}
    \only<2->{\TZPEast{}}
   \only<4->{\TZPNorth{}}
   \visible<3->{\TZPWest{}}
   \only<5->{\TZPSouth{}}
    
 \end{TIKZP}}
 
 \only<5->{
 \BigSkip{}
 We typically express angles in radians in quantum computing, so the circle has $2\pi$ radians.  We proceed around the circle counterclockwise, beginning at point~$+1$.}

\end{frame}


\begin{frame}{From Cartesian to polar coordinates}
\TwoColumns{
\begin{itemize}
    \item<1-> A complex number $z$ as shown to the right is at the Cartesian coordinate
    \[z=r(\cos{\theta}+i\sin{\theta})\]
    \item<2-> From \href{https://en.wikipedia.org/wiki/Euler\%27s_formula}{Euler's formula}, we can write this as
    \[ z = \Polar{r}{\theta} \]
    
\end{itemize}
    
 }{%
  \begin{TIKZP}[scale=1.2]
    \UnitComplexCircle{}
    \draw[->,ultra thick] (1,0) arc (0:45:1) coordinate (z) ;
    \draw[thick] (0,0) -- (z) ;
    \TZText{0.5,0}{$\theta$}{above}
    \TZText{z}{$z$}{above right}
    \TZText{0.35,0.35}{$r$}{above}
    \TZPoint{1,0}{$(r,0)$}{below right}
 \end{TIKZP}
 }
 \only<3->{
\BigSkip{}The complex number \Polar{r}{\theta} can thus be found by starting at $(r,0)$ and walking counterclockwise around a circle of radius $r$,
traversing a distance of $\theta$ radians along the circle.}
\end{frame}

\begin{frame}{Complex numbers in polar coordinates}{Useful properties}
\TwoColumns{%
Multiplication and Conjugation
\begin{itemize}
    \item How to multiply $z_1z_2$?
    \item<2-> $z_1z_2 = \Polar{r}{\theta_1}\Polar{r}{\theta_2}$
    \item<2-> $z_1z_2 = \Polar{r}{(\theta_1+\theta_2)}$
    \item<3-> How do we find $\Conj{z}$?
    \item<4-> $\Conj{z} = \overline{\Polar{r}{\theta}}$
    \item<4-> $\Conj{z} = \overline{r(\cos{\theta}+i\sin{\theta})}$
    \item<4-> $\Conj{z} = r(\cos{\theta}-i\sin{\theta})$
    \item<4-> $\Conj{z} = r(\cos{-\theta}+i\sin{-\theta})$
    \item<4-> $\Conj{z} = \Polar{r}{(-\theta)}$
\end{itemize}
}{
Magnitude
}
    
\end{frame}

\section{Linear algebra}

\begin{frame}{Overview of linear algebra}{Quantum systems are linear!}
\begin{itemize}
    \item While much of our world behaves nonlinearly, quantum systems can surprisingly be captured using linear algebra.
    \item Vectors and matrices can represent states and gates.  
    \begin{itemize}
        \item The state of a quantum system is most often described as a column vector, called a \href{https://en.wikipedia.org/wiki/Bra-ket_notation}{ket}.
         \item The effect of a quantum gate can be described as a square matrix, which maps in input ket to an output ket.
    \end{itemize}
    \item This is convenient but not efficient in the number of quantum bits.
    \item The composition of states and gates is computed using \href{https://en.wikipedia.org/wiki/Tensor}{tensor arithmetic}.
\end{itemize}
    
\end{frame}

\begin{frame}{Bra-ket notation}{Describing quantum states}
Quantum computing borrows notation from physics in using \href{https://en.wikipedia.org/wiki/Paul_Dirac}{Paul Dirac}'s \href{https://en.wikipedia.org/wiki/Bra-ket_notation}{bra-ket} notation.
\TwoColumns{%
\begin{itemize}
\item<1-> We typically represent a quantum state using a column vector.


\item<2-> Dirac calls such a vector a \emph{ket}, using this syntax that looks strange, but will soon become useful.


\end{itemize}
}{
\[
\visible<2->{\ket{\psi} = }
\begin{pmatrix}
0.5\\ i \\ 5+3i \\ \sqrt{2}

\end{pmatrix}
\]
\visible<3->{The letter $\psi$ is typically used in quantum computing to represent \alert{p}state, and especially \alert{p}superpositions.}
}

\only<4->{\BigSkip{} The \emph{bra} of a ket is its conjugate transpose, and \VV{}.
\[
\bra{\psi} =
\begin{pmatrix}
0.5 & -i & 5-3i &  \sqrt{2}
\end{pmatrix}
\]
}
\end{frame}

\begin{frame}{Inner Products}
The complete bra-ket of a state is the inner product of its bra with its ket, which computes the magnitude of the state, squared:
\begin{eqnarray*}
\braket{\psi}{\psi} & = &
\begin{pmatrix}
0.5 & -i & 5-3i &  \sqrt{2}
\end{pmatrix}
\times\begin{pmatrix}
0.5\\ i \\ 5+3i \\ \sqrt{2}
\end{pmatrix}
\\
 & = & 0.5^{2} + -i^{2} + 25-9i^{2} + 2 
\end{eqnarray*}
    
\end{frame}

\begin{frame}{Outer products}
If we instead multiply a ket-bra pair, we obtain an outer product.
This is helpful if we know how we want an operator to behave but don't know how to construct the matrix. Consider we want to build a NOT gate (Pauli X)
\begin{itemize}
    \item We want the following behavior:
    \item \ket{0} maps to \ket{1}
    \item \ket{1} maps to \ket{0}
\end{itemize}
Using outer products gives
\[\ket{0}\bra{1} + \ket{1}\bra{0} = 
\begin{pmatrix}
1 \\ 0
\end{pmatrix}
\begin{pmatrix}
0 & 1
\end{pmatrix}
+
\begin{pmatrix}
0 \\ 1
\end{pmatrix}
\begin{pmatrix}
1 & 0
\end{pmatrix}
= 
\begin{pmatrix}
0 & 1 \\
1 & 0
\end{pmatrix}
= \PauliX{}
\]
We can also prove a more general argument that uses outer products to construct any $n$-qubit operator.
\ToDo{finish this}
\end{frame}

\begin{frame}{Unit vectors}

\ToDo{finish this}
\end{frame}



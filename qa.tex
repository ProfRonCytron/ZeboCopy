\SetTitle{qa}{Quantum advantage}{How powerful are quantum computers?}{qapower}

\section{Overview}

\begin{frame}{Overview}{What do we know so far and what will we learn later?}
\only<1-4>{%
Our studies so far have taught us the following:
\begin{itemize}[<+->]
  \item With $n$ qubits we can create the superposition of $2^n$ inputs.
  \item We can realize any classical Boolean function using quantum circuit elements, so we can also create the superposition of $2^n$ function outputs.
  \item There are games that we cannot win classically but can win all the time using quantum computation.
  \item There are games that can be won with probability $p$ classically but can be won with greater probability using quantum computation.
\end{itemize}
}%
\only<5->{%
Our upcoming studies will teach us the following:
\begin{itemize}[<+->]
  \item<5-> There are problems such as \href{https://en.wikipedia.org/wiki/Deutsch-Jozsa_algorithm}{Deutsch--Joza} where we can get an exact solution in polynomial time on a quantum computer that would take exponential time on a classical computer.  
  \item<6-> A quantum computer can factor numbers using \href{https://en.wikipedia.org/wiki/Shor's_algorithm}{Shor's algorithm}, which is thought to be a hard problem.  If that problem is as hard as we suspect, then we achieve exponential speedup on an interesting problem using a quantum computer.
  \item<7-> Any unstructured search problem with $N=2^n$ possible choices can be solved in $O(\sqrt{N})$ time by \href{https://en.wikipedia.org/wiki/Grover's_algorithm}{Grover's algorithm} on a quantum computer. While this is remarkable, it is not exponentially faster than the best classical search time, $O(N)$.
\end{itemize}
}%


    
\end{frame}

\begin{frame}{Reasons for skepticism}{Devices and problems}

\begin{itemize}[<+->]
    \item Will quantum computers of reasonable size and fidelity be possible?
    \begin{itemize}
        \item This seems to be an engineering problem.
        \item \href{https://en.wikipedia.org/wiki/Moore's_law}{Moore's ``law''} predicted a steep curve for scaling of classical computational power.
        \item When I was in college, 300 MB of storage weighed 50 pounds.
        \item There are continually \href{https://www.google.com/search?q=quantum+computing+advances&rlz=1C5CHFA_enUS706US706&oq=quantum+computing+advances&ie=UTF-8}{press releases} concerning advances in technology.
    \end{itemize}
    \item For what kinds of problems will quantum computers provide significant speedup over classical computers?
    \begin{itemize}
        \item  \href{https://en.wikipedia.org/wiki/Molecular_modelling}{Molecular modeling} predicts the shape and possible activity of a molecule.  \href{https://venturebeat.com/2019/07/14/ibm-research-explains-how-quantum-computing-works-and-could-be-the-the-supercomputer-of-the-future/}{Here} is a discussion of modeling the caffeine molecule efficiently.
        \item There is hope of modeling \href{https://www.newscientist.com/article/2253089-google-performed-the-first-quantum-simulation-of-a-chemical-reaction/}{chemical reactions} efficiently.
    \end{itemize}
\end{itemize}
\OnlyRemark{9}{%
Before useful devices emerge, computer science can ask questions related to the complexity of problems when solved on a quantum computer.}
    
\end{frame}

\section{Complexity}

\begin{frame}{Time Complexity}{A review}
\begin{itemize}[<+->]
    \item In \href{https://en.wikipedia.org/wiki/Formal_language}{formal language theory}, $\Sigma$ is the alphabet of discourse. For example, it may be the Latin alphabet (a--z), or a binary alphabet ($0$ and $1$).  It is a finite set of symbols that allows us to have a conversation.  We assume $\Sigma\not=\emptyset$.
    \item $\Star{\Sigma}$ is the infinite set of all strings that consist of symbols drawn from $\Sigma$.  That set includes the empty string $\EmptyString$, which has length $0$, all strings of length $1$, all strings of length $2$, and so on.  Each string in $\Star{\Sigma}$ is finite.
    \item In complexity theory, we may be interested in how much time an algorithm needs to compute a result as a function of the size of its input
    \item Complexity classes are typically described using \href{https://en.wikipedia.org/wiki/Turing_machine}{Turing Machines (TM)}.  It's equivalent and more intuitive to say ``computer program'' as long as that program is written in a \href{https://en.wikipedia.org/wiki/Turing_completeness}{Turing-complete} programming language such as python.
    \end{itemize}
\end{frame}

\begin{frame}{Computer programs as a machine model}{We must account carefully.}

\begin{itemize}[<+->]
   \item The TM model is clear concerning a single step of the TM.
   \item If we use a program as a model for executing an algorithm, instead of a TM, then we must be account carefully.
   \item For example, the phrase \texttt{A[i]} may mean one of the following:
   \begin{description}
        \item[array index]  A constant number of operations turns \texttt{i} into an address, and we assume memory reads take constant time.
        \item[hash lookup]  A hash function is applied to $i$ to compute an array index. The time taken by such functions is expected to be constant, but may take $\omega(1)$ time for a hash table with $n$ entries.
        \item[list traversal]  A linked list of $n$ items may require traversal by this operation, in which case its expected and worst time is $\Theta(n)$.
   \end{description}
\end{itemize}
\visible<7>{%
In this course we are generally concerned with times that are either polynomial or superpolynomial, so the simplifications imposed here should work fine.}

\end{frame}


\begin{frame}{Promise problems}{Overview}
    \begin{itemize}[<+->]
    \item Many algorithms begin with phrases such as ``Given a graph with an even number of vertices, $\ldots$''.  What do such algorithms do with inputs that do not characterize a graph with an even number of vertices?
    \item \href{https://en.wikipedia.org/wiki/Promise_problem}{Promise problems} are a convenient way to focus analysis only on instances of a problem that have the desired properties.
    \item We \emph{promise} to provide an instance of a problem that respects the conditions of the promise.
    \item The algorithm is required to respond ``yes'' or ``no'' to such instances.
    \item The algorithm has no requirement concerning its response, if any, for other instances.
\end{itemize}

\end{frame}
\begin{frame}{Promise problems}{Definition}

\begin{itemize}[<+->]
    \item A promise problem is a pair $A=(A_{yes}, A_{no})$.
    \begin{itemize}
        \item $A_{yes} \subseteq \Star{\Sigma}$ and $A_{no} \subseteq \Star{\Sigma}$ for an alphabet of discourse $\Sigma$.
        \item $\Intersect{A_{yes}}{A_{no}}=\emptyset$
    \end{itemize}
    \item An algorithm under consideration must answer \emph{yes} for every string in $A_{yes}$ and it must answer \emph{no} for every string in $A_{no}$.
    
    \item It may be computationally difficult or impossible to determine if $x \in \Union{A_{yes}}{A_{no}}$, but the \emph{promise} is that $x$ is in one of those sets.
    \begin{itemize}
        \item Given a \href{https://en.wikipedia.org/wiki/Hamiltonian_path}{Hamiltonian} graph, $\ldots$  This is an \href{https://en.wikipedia.org/wiki/NP-completeness}{NP-Complete} problem.
        \item Given a program that \href{https://en.wikipedia.org/wiki/Halting_problem}{halts}, $\ldots$  This is an \href{https://en.wikipedia.org/wiki/Undecidable_problem}{undecidable problem}.
    \end{itemize}
    \item An algorithm has no obligation concerning any string $x\not\in \Union{A_{yes}}{A_{no}}$.
    \begin{itemize}
        \item It may run forever without providing an answer.
        \item It may provide an answer immediately without examining the input.
    \end{itemize}
    \item A \href{https://en.wikipedia.org/wiki/Complexity_class}{complexity class} is then a set of promise problems that have similar, desired properties.
\end{itemize}
\Exercise{promiseprobs}{Explain why neither of the two sets should be finite}
    
\end{frame}
\begin{frame}{Complexity class \CompClass{P}}{Using promise problems}

\begin{itemize}
    \item[\CompClass{P}] contains $A=(A_{yes},A_{no})$ if and only if there exists a \href{https://en.wikipedia.org/wiki/Time_complexity\#Polynomial_time}{polynomial-time} program $M$ that accepts every string in $A_{yes}$ and rejects every string in $A_{no}$.  Let's say $M(x)$ returns \True{} or \False{} to accept or reject $x$, respectively.
\end{itemize}
As an example, given a positive odd number greater than $2$, is that number prime?
\begin{itemize}
    \item We are promised that the input is a positive odd integer that is at least $3$.
    \item Given such an input $n$,\textbf{} program $M(n)$ can try every integer $i$ in the open interval $(1,n$) and see if $i$ divides evenly into $n$.  If none do, then
    $n\in A_{yes}$ and otherwise $n\in A_{no}$.
    \item If the promise is broken, $M$ could run indefinitely, return \True{}, or return \False{}.
\end{itemize}
$M$ can do this work in polynomial time, as long as each division operation also takes time polynomial in $n$.
This problem is therefore in \CompClass{P}.
\end{frame}
\begin{frame}{The complexity class \CompClass{NP}}{Using promise problems}

\begin{itemize}
    \item[\CompClass{NP}] is the class of promise problems with polynomially long proofs of membership that are verifiable in (deterministic) polynomial time. \LinkArrow{http://www.wisdom.weizmann.ac.il/~oded/PSX/prpr-r.pdf}  
    
    For any promise problem in \CompClass{NP}, its $M(x)$ returns a string $y$, and not just \True{} or \False{}.
    \begin{itemize}
        \item If $M$ accepts $x$, then $x\in A_{yes}$ and $y=M(x)$ is a proof of that.  
        \item If $M$ rejects $x$, then $x\in A_{no}$ and $y=M(x)=\EmptyString$, as no proof is required.
    \end{itemize}
    \MedSkip{}
    For all $x \in A_{yes}$ we require the following of the program $M$:
    \begin{itemize}
        \item There exists a polynomial $p$ such that \[\Mag{M(x)} \leq p(\Mag{x})\]
        so that the length of the proof is bounded by a polynomial.
        \item  The problem of verifying proofs ($y=M(x)\rightarrow x\in A_{yes}$)must be in \CompClass{P}.  Also, any  ``proof'' of $x\in A_{yes}$ when really $x\in A_{no}$ must similarly be found faulty.
        We are obligated to say how this is done.
    \end{itemize}
    
\end{itemize}
\end{frame}
\begin{frame}{Traveling SalesPerson (TSP) is in \CompClass{NP}}{Example}
As an example, given a graph of $n$ cities with positive edge weights, is there a \emph{tour} of all the cities with cost no greater than $L$?  A tour starts and ends at the same city and includes all other cities exactly once.

This problem can be solved by program $y=M(x)$ that tries every possible sequence of edges in the provided graph $x$.
\begin{itemize}
    \item If $M$ finds a suitable tour, then it determines $x\in A_{yes}$ and returns $y$ as a listing of edges that achieves the tour.  The veracity of $y$ can be efficiently checked to ensure the tour properly visits all cities and that the edges' weights sum to a value not exceeding $L$.
    \item If $M$ finds no acceptable tour, then it determines $x \in A_{no}$.  No proof is necessary, and $M$ returns $\EmptyString{}$.
\end{itemize}
Therefore $\mbox{TSP}\in \CompClass{NP}$.
    
\end{frame}

\begin{frame}{Aaronson results about classical simulation of some quantum circuits}{Aaronson--Gottesman paper}
    
\end{frame}

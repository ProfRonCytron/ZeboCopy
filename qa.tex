\SetTitle{qa}{Quantum advantage}{How powerful are quantum computers?}{qapower}

\begin{frame}{Overview}{What do we know so far and what will we learn later?}
\only<1-4>{%
Our studies so far have taught us the following:
\begin{itemize}[<+->]
  \item With $n$ qubits we can create the superposition of $2^n$ inputs.
  \item We can realize any classical Boolean function using quantum circuit elements, so we can also create the superposition of $2^n$ function outputs.
  \item There are games that we cannot win classically but can win all the time using quantum computation.
  \item There are games that can be won with probability $p$ classically but can be won with greater probability using quantum computation.
\end{itemize}
}%
\only<5->{%
Our upcoming studies will teach us the following:
\begin{itemize}[<+->]
  \item<5-> There are problems such as \href{https://en.wikipedia.org/wiki/Deutsch-Jozsa_algorithm}{Deutsch--Joza} where we can get an exact solution in polynomial time on a quantum computer that would take exponential time on a classical computer.  
  \item<6-> A quantum computer can factor numbers using \href{https://en.wikipedia.org/wiki/Shor's_algorithm}{Shor's algorithm}, which is thought to be a hard problem.  If that problem is as hard as we suspect, then we achieve exponential speedup on an interesting problem using a quantum computer.
  \item<7-> Any unstructured search problem with $N=2^n$ possible choices can be solved in $O(\sqrt{N})$ time by \href{https://en.wikipedia.org/wiki/Grover's_algorithm}{Grover's algorithm} on a quantum computer. While this is remarkable, it is not exponentially faster than the best classical search time, $O(N)$.
\end{itemize}
}%


    
\end{frame}

\begin{frame}{Reasons for skepticism}{Devices and problems}

\begin{itemize}[<+->]
    \item Will quantum computers of reasonable size and fidelity be possible?
    \begin{itemize}
        \item This seems to be an engineering problem.
        \item \href{https://en.wikipedia.org/wiki/Moore's_law}{Moore's ``law''} predicted a steep curve for scaling of classical computational power.
        \item When I was in college, 300 MB of storage weighed 50 pounds.
        \item There are continually \href{https://www.google.com/search?q=quantum+computing+advances&rlz=1C5CHFA_enUS706US706&oq=quantum+computing+advances&ie=UTF-8}{press releases} concerning advances in technology.
    \end{itemize}
    \item For what kinds of problems will quantum computers provide significant speedup over classical computers?
    \begin{itemize}
        \item  \href{https://en.wikipedia.org/wiki/Molecular_modelling}{Molecular modeling} predicts the shape and possible activity of a molecule.  \href{https://venturebeat.com/2019/07/14/ibm-research-explains-how-quantum-computing-works-and-could-be-the-the-supercomputer-of-the-future/}{Here} is a discussion of modeling the caffeine molecule efficiently.
        \item There is hope of modeling \href{https://www.newscientist.com/article/2253089-google-performed-the-first-quantum-simulation-of-a-chemical-reaction/}{chemical reactions} efficiently.
    \end{itemize}
\end{itemize}
\OnlyRemark{9}{%
Before useful devices emerge, computer science can ask questions related to the complexity of problems when solved on a quantum computer.}
    
\end{frame}

\begin{frame}{Time Complexity}{A review}
\begin{itemize}[<+->]
    \item In \href{https://en.wikipedia.org/wiki/Formal_language}{formal language theory}, $\Sigma$ is the alphabet of discourse. For example, it may be the Latin alphabet (a--z), or a binary alphabet ($0$ and $1$).  It is a finite set of symbols that allows us to have a conversation.  We assume $\Sigma\not=\emptyset$.
    \item $\Star{\Sigma}$ is the infinite set of all strings that consist of symbols drawn from $\Sigma$.  That set includes the empty string $\EmptyString$, which has length $0$, all strings of length $1$, all strings of length $2$, and so on.  Each string in $\Star{\Sigma}$ is finite.
    \item In complexity theory, we may be interested in how much time an algorithm needs to compute a result as a function of the size of its input.
    \item Many algorithms begin with phrases such as ``Given a graph with an even number of vertices, $\ldots$''.  What do such algorithms do with inputs that do not characterize a graph with an even number of vertices?
    \item \href{https://en.wikipedia.org/wiki/Promise_problem}{Promise problems} are a convenient way to focus analysis only on instances of a problem that have the desired properties.
\end{itemize}

\end{frame}
\begin{frame}{Promise problems}{A handy framework for studying complexity of quantum algorithms}

\begin{itemize}[<+->]
    \item A promise problem is a pair $A=(A_{yes}, A_{no})$.
    \begin{itemize}
        \item $A_{yes} \subseteq \Star{\Sigma}$ and $A_{no} \subseteq \Star{\Sigma}$ for an alphabet of discourse $\Sigma$.
        \item $\Intersect{A_{yes}}{A_{no}}=\emptyset$
    \end{itemize}
    \item An algorithm under consideration must answer \emph{yes} for every string in $A_{yes}$ and it must answer \emph{no} for every string in $A_{no}$.
    
    \item It may be computationally difficult or impossible to determine if $x \in \Union{A_{yes}}{A_{no}}$, but the \emph{promise} is that $x$ is in one of those sets.
    \begin{itemize}
        \item Given a \href{https://en.wikipedia.org/wiki/Hamiltonian_path}{Hamiltonian} graph, $\ldots$
        \item Given a program that \href{https://en.wikipedia.org/wiki/Halting_problem}{halts}, $\ldots$
    \end{itemize}
    \item An algorithm has no obligation concerning any string $x\not\in \Union{A_{yes}}{A_{no}}$.
    \begin{itemize}
        \item It may run forever without providing an answer.
        \item It may provide an answer immediately without consuming the input.
    \end{itemize}
    \item A \href{https://en.wikipedia.org/wiki/Complexity_class}{complexity class} is then a set of promise problems that have similar, desired properties.
\end{itemize}
\Exercise{promiseprobs}{Explain why neither of the two sets should be finite}
    
\end{frame}
\begin{frame}{Complexity class \CompClass{P}}{Using promise problems}
These classes are typically described using \href{https://en.wikipedia.org/wiki/Turing_machine}{Turing Machines}.  It's equivalent and more intuitive to say ``computer program'' as long as that program is written in a \href{https://en.wikipedia.org/wiki/Turing_completeness}{Turing-complete} programming language such as python.
\begin{itemize}
    \item[\CompClass{P}] contains $A=(A_{yes},A_{no})$ if and only if there exists a polynomial-time program $M$ that accepts every string in $A_{yes}$ and rejects every string in $A_{no}$.
\end{itemize}
As an example, given a positive odd number, is that number prime?
\begin{itemize}
    \item We are promised that the input is a positive odd number.
    \item Assuming division takes constant time, given an input $n$ we can try every integer $i$ in the open interval $(1,n$) and see if $i$ divides evenly into $n$ in time~$\Theta(n)$.  If none do, then
    $n\in A_{yes}$ and otherwise $n\in A_{no}$.
\end{itemize}
This problem is therefore in \CompClass{P}, and remains in \CompClass{P} if division takes $O(n)$ time.
\end{frame}
\begin{frame}{The complexity class \CompClass{NP}}{Using promise problems}

\begin{itemize}
    \item[\CompClass{NP}] is the class of promise problems with polynomially long proofs of membership that are verifiable in (deterministic) polynomial time. \LinkArrow{http://www.wisdom.weizmann.ac.il/~oded/PSX/prpr-r.pdf}  For a promise problem $A\in\CompClass{NP}$, each element of $\Union{A_{yes}}{A_{no}}$ is of the form $(x,y)$ where
    \begin{itemize}
        \item[x] is properly identified by some program $M$ as belonging either to $A_{yes}$ or $A_{no}$ when accompanied by a valid $y$.
        \item[y] is a proof of membership.  For $(x,y)\in A_{no}$ we allow $y=\EmptyString{}$ (no proof).  For all $(x,y)\in A_{yes}$, we require that there exists a polynomial $p$ such that $\Mag{y} \leq p(\Mag{x})$ and $y$ must prove $(x,y)\in A_{yes}$ in (deterministic) polynomial time.
    \end{itemize}
    
\end{itemize}
\end{frame}
\begin{frame}{Traveling SalesPerson (TSP) is in \CompClass{NP}}{Example}
As an example, given a positive-weighted graph of $n$ cities, is there a \emph{tour} of all the cities with cost no greater than $L$?  A tour starts and ends at the same city and includes all other cities exactly once.

This problem can be solved by program $M$ that tries every possible sequence of edges in the provided graph.
\begin{itemize}
    \item If $M$ finds a suitable tour, then it determines $(x,y)\in A_{yes}$ where $y$ is the listing of edges that achieves the tour.  The veracity of $y$ can be checked to make sure that every city is visited once and that the edges' weights sum to a value not exceeding $L$.
    \item If $M$ finds no acceptable tour, then it determines $(x,\EmptyString{}) \in A_{no}$.  No proof is necessary, but $M$ properly determined membership in $A_{no}$.
\end{itemize}
Therefore $\mbox{TSP}\in \CompClass{NP}$.
    
\end{frame}
\SetTitle{21}{Deutsch's Problem}{Is $f(x)$ constant or balanced?}{21}

\begin{frame}{Deutsch's problem}{Formulation}

\begin{itemize}
    \item We are given an oracle $f(x): \Set{0,1} \mapsto \Set{0,1}$
    \item We can characterize $f(x)$ as follows:
    \begin{description}
        \item[constant]   \Forall{x}{f(x)=k}, where $k$ is $0$ or $1$
        \item[balanced]   For half of its inputs, $f(x)=1$ and for the other half $f(x)=0$
    \end{description}
    \item Given the domain and range of $f(x)$, the function must be one of the above.
\end{itemize}
    
\end{frame}

\begin{frame}{Possible functions}{There are only four.}

\TwoColumns{%
\visible<2->{\begin{center}\alert{Constant}\end{center}}
\SBitTable{A}{0}{0}{1}{0}
\SBitTable{B}{0}{1}{1}{1}
}{%
\visible<3>{\begin{center}\alert{Balanced}\end{center}}
\SBitTable{C}{0}{0}{1}{1}
\SBitTable{D}{0}{1}{1}{0}
}
    
\end{frame}

\begin{frame}{Form of the oracle}{It has to be reversible.}
\TwoUnequalColumns{0.6\textwidth}{0.4\textwidth}{%
\begin{itemize}[<+->]
    \item We consider a quantum gate $U_f$ that implements $f(x)$.
    \item It accepts $x$ and an \href{https://en.wikipedia.org/wiki/Ancilla_bit}{ancillary} input $y$.
    \item It copies $x$ onto the top output qubit.
    \item It computes \alert{\Xor{y}{f(x)}} on the bottom output qubit.
    \item When $y=\QZero{}$ the bottom qubit is $\Xor{0}{f(x)}=f(x)$.
    \item When $y=\QOne{}$ the bottom qubit is $\Xor{1}{f(x)}=\Not{f(x)}$.
\end{itemize}
}{%
\BigSkip{}
\only<1>{%
\begin{Oracle}[scale=0.75]{$U_f$}{\relax}{\relax}{\relax}{\relax}
\end{Oracle}}%
\only<2>{%
\begin{Oracle}[scale=0.75]{$U_f$}{$x$}{$y$}{\relax}{\relax}
\end{Oracle}}%
\only<3>{%
\begin{Oracle}[scale=0.75]{$U_f$}{$x$}{$y$}{$x$}{\relax}
\end{Oracle}}%
\only<4>{%
\begin{Oracle}[scale=0.75]{$U_f$}{$x$}{$y$}{$x$}{\alert{\Xor{y}{f(x)}}}
\end{Oracle}}%
\only<5>{%
\begin{Oracle}[scale=0.75]{$U_f$}{$x$}{\QZero{}}{$x$}{$f(x)$}
\end{Oracle}}%
\only<6>{%
\begin{Oracle}[scale=0.75]{$U_f$}{$x$}{\QOne{}}{$x$}{\Not{$f(x)$}}
\end{Oracle}}%
}    
\end{frame}



\begin{frame}{Realizing the oracle for \Quote{A}: $f(x)=0$}{We design a circuit that meets the classical specification.}

\TwoColumns{%
\Vskip{-3em}\begin{center}
\begin{TTable}{A}{$x$}{$f(x)$}
\TRow{ }{0}{0}
\TRow{ }{1}{0}
\end{TTable}
\end{center}
\BigSkip{}
\visible<2->{%
\begin{center}
\begin{UTable}{$U_A$}{$x$}{$y$}{$f(x)$}{$x$}{\Xor{y}{f(x)}}
\URow{}{0}{0}{0}{0}{0}
\URow{}{0}{1}{0}{0}{1}
\URow{}{1}{0}{0}{1}{0}
\URow{}{1}{1}{0}{1}{1}
\end{UTable}\end{center}}
}{%
\begin{Oracle}[scale=0.75]{$U_A$}{$x$}{$y$}{$x$}{\Xor{y}{f(x)}}
\end{Oracle}

\BigSkip{}
\visible<3->{%
\Forall{x}{f(x)=0}, so $\Xor{y}{f(x)}=\Xor{y}{0}=y$.  
\MedSkip{}
Thus, $U_A$ is just the identity function, so our quantum circuit doesn't have to do anything to its inputs to realize $U_A$.}

\BigSkip{}
\visible<4>{%
\begin{center}
\adjustbox{valign=t}{\begin{quantikz}
\lstick{\ket{x}} &  \qw & \qw \rstick{\ket{x}} \\
\lstick{\ket{y}} &  \qw & \qw \rstick{\ket{\Xor{y}{f(x)}}}
\end{quantikz}}\end{center}
}
}
    
\end{frame}

\begin{frame}{Realizing the oracle for \Quote{B}: $f(x)=1$}{We design a circuit that meets the classical specification.}

\TwoColumns{%
\Vskip{-3em}\begin{center}
\begin{TTable}{B}{$x$}{$f(x)$}
\TRow{ }{0}{1}
\TRow{ }{1}{1}
\end{TTable}
\end{center}
\BigSkip{}
\visible<2->{%
\begin{center}
\begin{UTable}{$U_B$}{$x$}{$y$}{$f(x)$}{$x$}{\Xor{y}{f(x)}}
\URow{}{0}{0}{1}{0}{1}
\URow{}{0}{1}{1}{0}{0}
\URow{}{1}{0}{1}{1}{1}
\URow{}{1}{1}{1}{1}{0}
\end{UTable}\end{center}}
}{%
\begin{Oracle}[scale=0.75]{$U_B$}{$x$}{$y$}{$x$}{\Xor{y}{f(x)}}
\end{Oracle}

\BigSkip{}
\visible<3->{%
\Forall{x}{f(x)=1}, so $\Xor{y}{f(x)}=\Xor{y}{1}=\Not{y}$.  
\MedSkip{}
Thus, $U_B$ is realized by complementing $y$.}

\BigSkip{}
\visible<4>{%
\begin{center}
\adjustbox{valign=t}{\begin{quantikz}
\lstick{\ket{x}} &  \qw & \qw \rstick{\ket{x}} \\
\lstick{\ket{y}} &  \gate{X} & \qw \rstick{\ket{\Xor{y}{f(x)}}}
\end{quantikz}}\end{center}
}
}
    
\end{frame}

\begin{frame}{Realizing the oracle for \Quote{C}: $f(x)=x$}{We design a circuit that meets the classical specification.}

\TwoColumns{%
\Vskip{-3em}\begin{center}
\begin{TTable}{C}{$x$}{$f(x)$}
\TRow{ }{0}{0}
\TRow{ }{1}{1}
\end{TTable}
\end{center}
\BigSkip{}
\visible<2->{%
\begin{center}
\begin{UTable}{$U_C$}{$x$}{$y$}{$f(x)$}{$x$}{\Xor{y}{f(x)}}
\URow{}{0}{0}{0}{0}{0}
\URow{}{0}{1}{0}{0}{1}
\URow{}{1}{0}{1}{1}{1}
\URow{}{1}{1}{1}{1}{0}
\end{UTable}\end{center}}
}{%
\begin{Oracle}[scale=0.75]{$U_C$}{$x$}{$y$}{$x$}{\Xor{y}{f(x)}}
\end{Oracle}

\BigSkip{}
\visible<3->{%
\Forall{x}{f(x)=x}, so $\Xor{y}{f(x)}=\Xor{y}{x}$.}%

\BigSkip{}
\only<3>{%
The matrix may look familiar...
\[U_{C} = \CNOTMatrix{} \]
}%
\only<4>{%
Thus, a \NamedGate{CNOT} gate will flip $y$ when $x$ is~$1$:
\begin{center}
\adjustbox{valign=t}{\begin{quantikz}
\lstick{\ket{x}} &  \ctrl{1} & \qw \rstick{\ket{x}} \\
\lstick{\ket{y}} &  \targ{} & \qw \rstick{\ket{\Xor{y}{f(x)}}}
\end{quantikz}}\end{center}
}
}
    
\end{frame}

\begin{frame}{Realizing the oracle for \Quote{D}: $f(x)=\Not{x}$}{We design a circuit that meets the classical specification.}

\TwoColumns{%
\Vskip{-3em}\begin{center}
\begin{TTable}{D}{$x$}{$f(x)$}
\TRow{ }{0}{1}
\TRow{ }{1}{0}
\end{TTable}
\end{center}
\BigSkip{}
\visible<2->{%
\begin{center}
\begin{UTable}{$U_D$}{$x$}{$y$}{$f(x)$}{$x$}{\Xor{y}{f(x)}}
\URow{}{0}{0}{1}{0}{1}
\URow{}{0}{1}{1}{0}{0}
\URow{}{1}{0}{0}{1}{0}
\URow{}{1}{1}{0}{1}{1}
\end{UTable}\end{center}}
}{%
\begin{Oracle}[scale=0.75]{$U_D$}{$x$}{$y$}{$x$}{\Xor{y}{f(x)}}
\end{Oracle}

\BigSkip{}
\visible<3->{%
\Forall{x}{f(x)=\Not{x}}, so $\Xor{y}{f(x)}=\Xor{y}{\Not{x}}=\Not{\Xor{y}{x}}$.}%

\BigSkip{}
\only<3>{%
This is just like the previous case, except the output is the complement of what we had before.
}%
\only<4>{%
Thus, we add an \PauliX{} gate after the \NamedGate{CNOT} gate:
\begin{center}
\adjustbox{valign=t}{\begin{quantikz}
\lstick{\ket{x}} &  \ctrl{1} & \qw & \qw \rstick{\ket{x}} \\
\lstick{\ket{y}} &  \targ{} & \gate{X} & \qw \rstick{\ket{\Xor{y}{f(x)}}}
\end{quantikz}}\end{center}
}
}
    
\end{frame}

\begin{frame}{Is $f(x)$ constant or balanced?}{Classical approach}

\TwoColumns{%
\begin{itemize}[<+->]
    \item If we perform one evaluation of $f$, say on $0$, then we do not know if $f(x)$ is always $f(0)$ or if $f(1)$ may be different.
    \item Classically it takes \emph{two} queries of $f$ to determine the answer to this question.
    \visible<3-4>{Here $f(x)$ is \alt<3>{constant}{balanced}.}
\end{itemize}
}{%
\begin{align*}
    f(0) &= 0 \\
    \visible<2->{f(1) &= \alt<4>{1}{\alt<3>{0}{\ ?}}}
\end{align*}
}
\BigSkip{}
\visible<5>{We will see that a quantum circuit for $f$ can reveal whether the function is constant or balanced with \emph{a single} query!}
\end{frame}

\begin{frame}{Using superposition}{We can arrange for the quantum circuit to produce all possible answers.}

\Vskip{-3em}\begin{center}
\begin{GateBox}[scale=1.0]{2}{1.2}{2}
\BoxLabel{$U_f$}
\Input{0}{\alt<1>{\QPlus{}}{\ket{+}}}
\Input{1}{\alt<16->{\alert{\ket{-}}}{\QZero{}}}
\ComputeMyY{0}\draw (0,\MyY) node[right] {$x$};
\ComputeMyY{1}\draw (0,\MyY) node[right] {$y$};
\Output{0}{\alert<12-14>{$x$}}
\Output{1}{\alert<12-14>{\Xor{y}{f(x)}}}
\end{GateBox}
\end{center}
\TwoColumns{%
\only<1-3>{%
\begin{itemize}
    \item<1-> The input is the superposition of the two possible basis states.
    \item<2-> We know this state as \ket{+}.
    \item<3-> Recall we can create $\ket{+}=\QPlus{}$ using a Hadamard gate.
\end{itemize}}
}{%
\only<3>{%
\begin{center}
\adjustbox{valign=t}{\begin{quantikz}
\lstick{\QZero{}} &  \gate{H} &  \qw \rstick{\ket{+}}
\end{quantikz}}%
\end{center}}%
}%

\only<4-6>{%
    $U_f$ produces
        $\TensProd{x}{(\Xor{y}{f(x)})}  =
        \TensProd{x}{(\Xor{0}{f(x)})} 
        = \TensProd{x}{f(x)}
        = \alert{\ket{x\,f(x)}}$

\SmallSkip{}
By linearity, with $x$ in the superposition \QPlus{} and $y=\QZero{}$
    \begin{align*}
    U_f(\TensProd{\QPlus}{0}) &= \RootTwo{}U_f(\ket{00}+\ket{10}) \\
    \visible<5->{ &= \RootTwo{}\left(
        U_f(\ket{00}) + U_f(\ket{10})\right) \\}
       \visible<6->{ &= \frac{\ket{0\,f(0)} +
        \ket{1\,f(1)}}{\sqrt{2}}}
    \end{align*}}%
\only<7->{%
\visible<7-16>{
\[ U_{f}(\ket{+\,0}) = \TwoSup{0\,\textcolor<14>{\RCone}{f(0)}}{1\,\textcolor<14>{\RCtwo}{f(1)}} \]}}
\only<7-11>{%
\Vskip{-2em}\begin{itemize}
    \item<7-> We forced $U_f$ to produce \emph{both} outputs.
    \item<8-> But what happens if we measure?
    \item<9-> We randomly and uniformly see \emph{either} \ket{0\,f(0)} or \ket{1\,f(1)}.
    \item<10-> It could take \emph{more} than two evaluations to see both answers!
    \item<11-> Even if we measure only the top qubit, the bottom qubit collapses too.
\end{itemize}
}%
\only<12-14>{%
\Vskip{-2em}\begin{itemize}
    \item<12-> It is misleading to see the \alert<12>{output} of $U_f$ labeled to look like a tensor product.  $U_f$ will generate the outputs as specified, but the result is not necessarily expressible as \TensProd{x}{(\Xor{y}{f(x)})}.
    \item<13-> Without analysis, we cannot know if the output is tensor-factorable.
    \item<14-> Consider \textcolor{\RCone}{$f(0)=0$} and \textcolor{\RCtwo}{$f(1)=1$}.  Then $U_f$ creates \alert<14>{\TwoSup{00}{11}} as the (entangled) output, which we know cannot be tensor factored!
\end{itemize}
}%
\only<15->{%
\begin{itemize}
    \item<15-> While the information is in the output, we cannot recover it by measurement.
    \item<16-> We need to try something different, using \alert{interference} to get the result we need.
\end{itemize}
}
\end{frame}

\begin{frame}{Creating \ket{-}}{A few approaches}

\TwoUnequalColumns{0.6\textwidth}{0.4\textwidth}{%
\Vskip{-3em}\begin{itemize}[<+->]
    \item Recall 
    \begin{itemize}
        \item $\ket{+}=\QPlus{}$
        \item $\ket{-}=\QMinus{}$
    \end{itemize}
    \item Use \PauliZ{} on \ket{+}
    \[
    \ZMatrix{}\PPlus{} = \PMinus{}=\ket{-}\]
    \item Use \Hadamard{} on \QOne{}
    \[ \HMatrix{}\POne{} = \PMinus{}=\ket{-}
    \]
\end{itemize}
}{%
\BigSkip{}\BigSkip{}
\visible<4>{%
\begin{center}
\adjustbox{valign=t}{\begin{quantikz}
\lstick{\QZero{}} &  \gate{H} & \gate{Z}& \qw \rstick{\ket{-}}
\end{quantikz}}\end{center}}%
\BigSkip{}
\BigSkip{}
\BigSkip{}
\visible<5>{%
\begin{center}
\adjustbox{valign=t}{\begin{quantikz}
\lstick{\QOne{}} &  \gate{H} & \qw & \qw \rstick{\ket{-}}
\end{quantikz}}\end{center}}%
}
    
\end{frame}



\begin{frame}{Deutsch's algorithm}{Uses interference to find constant vs. balanced functions}

\Vskip{-4em}\TwoUnequalColumns{0.5\textwidth}{0.5\textwidth}{%
\begin{center}
\Vskip{-3em}\adjustbox{valign=t, width=\textwidth}{\begin{quantikz}
\lstick{\QZero{}} & \qw\slice{\alert<2>{\QState{0}}} &  \gate{H}\slice{\alert<3-5>{\QState{1}}} & \gate[wires=2][5em]{\mbox{$U_f$}}\gateinput{$x$}\gateoutput{$x$}\slice{\alert<6-8>{\QState{2}}} &\gate{H}\slice{\alert<9-10>{\QState{3}}} & \meter{\alt<30>{\alert{1}}{\alt<25>{\alert{0}}{0/1}}} \\
\lstick{\QZero{}} & \gate{X} &   \gate{H}   &  \qw\gateinput{$y$}\gateoutput{\Xor{y}{f(x)}} & \qw & \qw
\end{quantikz}}%
\end{center}
}{%
\only<1-7>{%
    \begin{align*}
        \visible<2->{\QState{0} &= \ket{01} \\}
        \only<3-5>{
        \visible<3->{\QState{1} &= \ket{+-} \visible<4->{= \frac{1}{2}\DQB{1}{-1}{1}{-1}}} \\}
        \visible<5->{\only<6->{\QState{1}}&= \frac{\ket{00}-\ket{01}+\ket{10}-\ket{11}}{2}}
    \end{align*}}%
\only<8-12>{%
\begin{align*}
    U_{f}(\ket{\textcolor{\RCone}{x}\textcolor{\RCtwo}{y}}) & = \ket{\textcolor{\RCone}{x}\,\Xor{\textcolor{\RCtwo}{y}}{f(\textcolor{\RCone}{x})}} \\
    \only<9>{U_{f}(\ket{\textcolor{\RCone}{0}\textcolor{\RCtwo}{0}}) & = \ket{\textcolor{\RCone}{0}\,\Xor{\textcolor{\RCtwo}{0}}{f(\textcolor{\RCone}{0})}}}
    \only<10>{U_{f}(\ket{\textcolor{\RCone}{0}\textcolor{\RCtwo}{1}}) & = \ket{\textcolor{\RCone}{0}\,\Xor{\textcolor{\RCtwo}{1}}{f(\textcolor{\RCone}{0})}}}
    \only<11>{U_{f}(\ket{\textcolor{\RCone}{1}\textcolor{\RCtwo}{0}}) & = \ket{\textcolor{\RCone}{1}\,\Xor{\textcolor{\RCtwo}{0}}{f(\textcolor{\RCone}{1})}}}
    \only<12>{U_{f}(\ket{\textcolor{\RCone}{1}\textcolor{\RCtwo}{1}}) & = \ket{\textcolor{\RCone}{1}\,\Xor{\textcolor{\RCtwo}{1}}{f(\textcolor{\RCone}{1})}}}
\end{align*}}
\only<13-18>{%
\begin{align*}
    \visible<13-15>{\Xor{0}{f(a)} &= f(a)} \\
    \visible<16->{\Xor{1}{f(a)} &= \Not{f(a)}}
\end{align*}}%
\only<22,27>{%
\BigSkip{}
\alert{Recall \[\ket{a\,b} = \ket{a}\ket{b} \]}
}%
\only<23-24>{%
\[ \alert{\ket{+} = \QPlus{}} \]
}%
\only<28-30>{%
\[ \alert{\ket{-} = \QMinus{}} \]
}%
\only<31>{%
\begin{center}
    \begin{tabular}{ccc}
        & \QState{2} & \QState{3} \\ 
        $f(x)$ & \multicolumn{2}{c}{(top qubit)}\\ \hline
    constant & \ket{+} & \QZero{} \\
    balanced & \ket{-} & \QOne{}
    \end{tabular}
\end{center}
}
}
\only<6-30>{
\Vskip{-2em}\begin{align*}
    \only<6-7>{\QState{2} &= U_f(\frac{1}{2}\left[\ket{00}-\ket{01}+\ket{10}-\ket{11}\right]) \\[1em]}
     \only<7->{\visible<8->{\QState{2}}   &= \frac{%
        \alt<14->{\ket{0\,f(0)}}{\alt<9->{\ket{0\,\alert<13>{\Xor{0}{f(0)}}}}{U_f(\ket{00})}}-\alt<17->{\ket{0\,\Not{f(0)}}}{\alt<10->{\ket{0\,\alert<16>{\Xor{1}{f(0)}}}}{U_f(\ket{01})}}  + \alt<15->{\ket{1\,f(1)}}{\alt<11->{\ket{1\,\alert<13-14>{\Xor{0}{f(1)}}}}{U_f(\ket{10})}}-\alt<18->{\ket{1\,\Not{f(1)}}}{\alt<12->{\ket{1\,\alert<16-17>{\Xor{1}{f(1)}}}}{U_f(\ket{11})}}}{2}}
\end{align*}}
\only<18-20>{%
\begin{itemize}
    \item<18-> For any $f(x)$, \QState{2} has 4 distinct terms: \ket{00}, \ket{01}, \ket{10}, and \ket{11}.
    \item<19-> $U_f$ determines which terms are positive and which are negative.
    \item<20-> If only the numerator contained \ket{0\,f(0)} - \ket{0\,f(1)}, then those terms would cancel if $f(0)$ is constant.
\end{itemize}
}
\only<21-25>{%
\Vskip{-2em}\TwoUnequalColumns{0.3\textwidth}{0.7\textwidth}{%
Suppose $f(0)=f(1)$.  \only<23-24>{%
Tensor-factored, this state tells us the \textcolor{\RCone}{top} and \textcolor{\RCtwo}{bottom} qubits' states.
}
\only<25>{Then the top qubit at \QState{2} is \ket{+}.  Measuring at \QState{3} yields \alert{\ket{0}}.}
}{%
\Vskip{-4em}\begin{align*}
    2\times\QState{2} &= \ket{0\,f(0)} - \ket{0\,\Not{f(0)}} + \ket{1\,\alert<21>{f(0)}} - \ket{1\,\Not{\alert<21>{f(0)}}} \\
  \visible<22->{  & = \TensProd{(\ket{0}+\ket{1})}{\ket{f(0)}} - \TensProd{(\ket{0}+\ket{1})}{\ket{\Not{f(0)}}} \\}
  \visible<23->{  & = \TensProd{\textcolor<23-24>{\RCone}{(\ket{0}+\ket{1})}}{\textcolor<23-24>{\RCtwo}{(\ket{f(0)}-\ket{\Not{f(0)}})}} \\}
  \visible<24->{ \QState{2} &= \TensProd{\textcolor<24>{\RCone}{\ket{+}}}{\textcolor<24>{\RCtwo}{(\ket{f(0)}-\ket{\Not{f(0)}})\frac{1}{\sqrt{2}}}} }
\end{align*}
}
}
\only<26-30>{%
\Vskip{-2em}\TwoUnequalColumns{0.3\textwidth}{0.7\textwidth}{%
Suppose $f(0) = \Not{f(1)}$. 
 \only<28-29>{%
Tensor-factored, this state tells us the \textcolor{\RCone}{top} and \textcolor{\RCtwo}{bottom} qubits' states.
}
\only<30>{Then the top qubit at \QState{2} is \ket{-}.  Measuring at \QState{3} yields \alert{\ket{1}}.}
}{%
\Vskip{-4em}\begin{align*}
    2\times\QState{2} &= \ket{0\,f(0)} - \ket{0\,\alert<26>{f(1)}} + \ket{1\,f(0)} - \ket{1\,\alert<26>{f(0)}} \\
  \visible<27->{  & = \TensProd{(\ket{0}-\ket{1})}{\ket{f(0)}} - \TensProd{(\ket{0}-\ket{1})}{\ket{f(1)}} \\}
  \visible<28->{  & = \TensProd{\textcolor<28-29>{\RCone}{(\ket{0}-\ket{1})}}{\textcolor<28-29>{\RCtwo}{(\ket{f(0)}-\ket{f(1)})}} \\}
  \visible<29->{ \QState{2} &= \TensProd{\textcolor<29>{\RCone}{\ket{-}}}{\textcolor<29>{\RCtwo}{(\ket{f(0)}-\ket{f(1)})\frac{1}{\sqrt{2}}}} }
\end{align*}
}
}
\only<31->{%
\MedSkip{}
\begin{itemize}
    \item<31-> We can determine if $f(x)$ is constant or balanced with a single query of $U_f$.  Classically two queries were needed.
    \item<32-> We perform a \href{https://physics.stackexchange.com/questions/184242/partial-measurement-and-the-math-behind-it}{partial measurement} of the system, measuring only the top qubit.
    \item<33-> This quantum circuit never created any entanglement:  each state could be tensor factored into the product of single qubit states.
    \item<34-> The effect of sending $y=\ket{-}$ into $U_f$ is manifest primarily on the top qubit.   We call this \emph{phase kickback} and study it next.
\end{itemize}
}

\end{frame}

\begin{frame}{What about the bottom qubit?}{Homework problem but let's take a quick look}

\Vskip{-4em}\begin{align*} 
\invisible<5>{f(0) = f(1) \longrightarrow &  \QState{2} = \TensProd{\textcolor{\RCone}{\ket{+}}}{\textcolor{\RCtwo}{(\ket{f(0)}-\ket{\Not{f(0)}})\frac{1}{\sqrt{2}}}} \\}
\invisible<4>{f(0) \not= f(1) \longrightarrow & \QState{2} = \TensProd{\textcolor{\RCone}{\ket{-}}}{\textcolor{\RCtwo}{(\ket{f(0)}-\ket{f(1)})\frac{1}{\sqrt{2}}}}}
\end{align*}
\Vskip{-2em}\begin{itemize}[<+->]
  \item Tensor factored, we can see the values present on the \textcolor{\RCone}{top} and \textcolor{\RCtwo}{bottom} qubits.
  \item You will analyze the \textcolor{\RCtwo}{bottom qubit's} value for each of the above cases.
  \item We note here that the input of \ket{-} for $y$ on the \textcolor{\RCtwo}{bottom qubit} has the effect of changing phase on the \textcolor{\RCone}{\emph{top} qubit's} value on output:
  \begin{description}
     \item[$f(0)=f(1)$] $\textcolor{\RCone}{\ket{+}}=\TwoSupOp{\ket{0}}{\alert{\ket{1}}}{\alert{+}}$
     \item[$f(0)\not=f(1)$] $\textcolor{\RCone}{\ket{-}}=\TwoSupOp{\ket{0}}{\alert{\ket{1}}}{\alert{-}}$
  \end{description}
  \item This is called \emph{phase kickback}.
\end{itemize}
\end{frame}
\SetTitle{21}{Deutsch's Problem}{Is $f(x)$ constant or balanced?}{20}

\begin{frame}{Deutsch's problem}{Formulation}

\begin{itemize}
    \item We are given an oracle $f(x): \Set{0,1} \mapsto \Set{0,1}$
    \item We can characterize $f(x)$ as follows:
    \begin{description}
        \item[constant]   \Forall{x}{f(x)=k}, where $k$ is $0$ or $1$
        \item[balanced]   For half of its inputs, $f(x)=1$ and for the other half $f(x)=0$
    \end{description}
    \item Because $x$ is a single bit, $f(x)$ must be one of the above.
\end{itemize}
    
\end{frame}

\begin{frame}{Possible functions}{There are only four.}

\TwoColumns{%
\visible<2->{\begin{center}\alert{Constant}\end{center}}
\SBitTable{A}{0}{0}{1}{0}
\SBitTable{B}{0}{1}{1}{1}
}{%
\visible<3>{\begin{center}\alert{Balanced}\end{center}}
\SBitTable{C}{0}{0}{1}{1}
\SBitTable{D}{0}{1}{1}{1}
}
    
\end{frame}

\begin{frame}{Form of the oracle}{It has to be reversible.}
\TwoUnequalColumns{0.6\textwidth}{0.4\textwidth}{%
\begin{itemize}[<+->]
    \item We consider a quantum gate $U_f$ that implements $f(x)$.
    \item It accepts $x$ and an \href{https://en.wikipedia.org/wiki/Ancilla_bit}{ancillary} input $y$.
    \item It copies $x$ onto the top output qubit.
    \item It computes \Xor{y}{f(x)} on the bottom output qubit.
    \item When $y=\ket{0}$ the bottom qubit is $f(x)$.
    \item When $y=\ket{1}$ the bottom qubit is \Not{$f(x)$}.
\end{itemize}
}{%
\BigSkip{}
\only<1>{%
\begin{Oracle}[scale=0.75]{$U_f$}{\relax}{\relax}{\relax}{\relax}
\end{Oracle}}%
\only<2>{%
\begin{Oracle}[scale=0.75]{$U_f$}{$x$}{$y$}{\relax}{\relax}
\end{Oracle}}%
\only<3>{%
\begin{Oracle}[scale=0.75]{$U_f$}{$x$}{$y$}{$x$}{\relax}
\end{Oracle}}%
\only<4>{%
\begin{Oracle}[scale=0.75]{$U_f$}{$x$}{$y$}{$x$}{\Xor{y}{f(x)}}
\end{Oracle}}%
\only<5>{%
\begin{Oracle}[scale=0.75]{$U_f$}{$x$}{\ket{0}}{$x$}{$f(x)$}
\end{Oracle}}%
\only<6>{%
\begin{Oracle}[scale=0.75]{$U_f$}{$x$}{\ket{1}}{$x$}{\Not{$f(x)$}}
\end{Oracle}}%
}    
\end{frame}

{
\def\V#1#2{\visible<#1->{\textcolor{#2}{\FCirc{0.30}}}}
\begin{frame}{Review of how the matrix sends inputs to outputs}{Linear algebra}

\TwoColumns{%
For a two-qubit system, recall the representation of bases as column vectors:
\begin{center}
    \begin{tabular}{cccc}
    \ket{00} & \ket{01} & \ket{10} & \ket{11} \\
    \textcolor<1->{\RCone}{\DQB{1}{0}{0}{0}} &
     \textcolor<2->{\RCtwo}{\DQB{0}{1}{0}{0}} &
      \textcolor<3->{\RCthree}{\DQB{0}{0}{1}{0}} &
       \textcolor<4->{\RCfour}{\DQB{0}{0}{0}{1}}
     \end{tabular}
\end{center}

Each column is the output produced when give its corresponding input basis vector.
}{%
We can thus think of the unitary matrix in terms of where it sends each of the basis vectors.
\[
\only<1-4>{U = }\begin{pmatrix*}[c]
  \ket{00} & \ket{01} & \ket{10} & \ket{11} \\
  \V{1}{\RCone} & \V{2}{\RCtwo} & \V{3}{\RCthree} & \V{4}{\RCfour} \\
  \V{1}{\RCone} & \V{2}{\RCtwo} & \V{3}{\RCthree} & \V{4}{\RCfour} \\
  \V{1}{\RCone} & \V{2}{\RCtwo} & \V{3}{\RCthree} & \V{4}{\RCfour} \\
  \V{1}{\RCone} & \V{2}{\RCtwo} & \V{3}{\RCthree} & \V{4}{\RCfour} 
\end{pmatrix*}
\only<5>{%
\textcolor{\RCone}{\DQB{1}{0}{0}{0}} = \DQB{\V{5}{\RCone}}{\V{5}{\RCone}}{\V{5}{\RCone}}{\V{5}{\RCone}}}
\only<6>{%
\textcolor{\RCtwo}{\DQB{0}{1}{0}{0}} = \DQB{\V{6}{\RCtwo}}{\V{6}{\RCtwo}}{\V{6}{\RCtwo}}{\V{6}{\RCtwo}}}
\only<7>{%
\textcolor{\RCthree}{\DQB{0}{0}{1}{0}} = \DQB{\V{7}{\RCthree}}{\V{7}{\RCthree}}{\V{7}{\RCthree}}{\V{7}{\RCthree}}}
\only<8>{%
\textcolor{\RCfour}{\DQB{0}{0}{0}{1}} = \DQB{\V{8}{\RCfour}}{\V{8}{\RCfour}}{\V{8}{\RCfour}}{\V{8}{\RCfour}}}
\]
\visible<5-8>{Applying the matrix to a given basis vector extracts the associated column.}
}

    
\end{frame}}

\begin{frame}{Using outer products}{To construct gates}

\href{https://qiskit.org/textbook/ch-states/single-qubit-gates.html\#1.1-The-X-Gate-}{see this}
    
\end{frame}

\begin{frame}{Realizing the oracle for \Quote{A}: $f(x)=0$}{We design a circuit that meets the classical specification.}

\TwoColumns{%
\Vskip{-3em}\begin{center}
\begin{TTable}{A}{$x$}{$f(x)$}
\TRow{ }{0}{0}
\TRow{ }{1}{0}
\end{TTable}
\end{center}
\BigSkip{}
\visible<2->{%
\begin{center}
\begin{UTable}{$U_A$}{$x$}{$y$}{$f(x)$}{$x$}{\Xor{y}{f(x)}}
\URow{}{0}{0}{0}{0}{0}
\URow{}{0}{1}{0}{0}{1}
\URow{}{1}{0}{0}{1}{0}
\URow{}{1}{1}{0}{1}{1}
\end{UTable}\end{center}}
}{%
\begin{Oracle}[scale=0.75]{$U_A$}{$x$}{$y$}{$x$}{\Xor{y}{f(x)}}
\end{Oracle}

\BigSkip{}
\visible<3->{%
\Forall{x}{f(x)=0}, so $\Xor{y}{f(x)}=\Xor{y}{0}=y$.  
\MedSkip{}
Thus, $U_A$ is just the identity function, so our quantum circuit doesn't have to do anything to its inputs to realize $U_A$.}

\BigSkip{}
\visible<4>{%
\begin{center}
\adjustbox{valign=t}{\begin{quantikz}
\lstick{\ket{x}} &  \qw & \qw \rstick{\ket{x}} \\
\lstick{\ket{y}} &  \qw & \qw \rstick{\ket{\Xor{y}{f(x)}}}
\end{quantikz}}\end{center}
}
}
    
\end{frame}

\begin{frame}{Realizing the oracle for \Quote{B}: $f(x)=1$}{We design a circuit that meets the classical specification.}

\TwoColumns{%
\Vskip{-3em}\begin{center}
\begin{TTable}{B}{$x$}{$f(x)$}
\TRow{ }{0}{1}
\TRow{ }{1}{1}
\end{TTable}
\end{center}
\BigSkip{}
\visible<2->{%
\begin{center}
\begin{UTable}{$U_B$}{$x$}{$y$}{$f(x)$}{$x$}{\Xor{y}{f(x)}}
\URow{}{0}{0}{1}{0}{1}
\URow{}{0}{1}{1}{0}{0}
\URow{}{1}{0}{1}{1}{1}
\URow{}{1}{1}{1}{1}{0}
\end{UTable}\end{center}}
}{%
\begin{Oracle}[scale=0.75]{$U_B$}{$x$}{$y$}{$x$}{\Xor{y}{f(x)}}
\end{Oracle}

\BigSkip{}
\visible<3->{%
\Forall{x}{f(x)=1}, so $\Xor{y}{f(x)}=\Xor{y}{1}=\Not{y}$.  
\MedSkip{}
Thus, $U_B$ is realized by complementing $y$.}

\BigSkip{}
\visible<4>{%
\begin{center}
\adjustbox{valign=t}{\begin{quantikz}
\lstick{\ket{x}} &  \qw & \qw \rstick{\ket{x}} \\
\lstick{\ket{y}} &  \gate{X} & \qw \rstick{\ket{\Xor{y}{f(x)}}}
\end{quantikz}}\end{center}
}
}
    
\end{frame}

\begin{frame}{Realizing the oracle for \Quote{C}: $f(x)=x$}{We design a circuit that meets the classical specification.}

\TwoColumns{%
\Vskip{-3em}\begin{center}
\begin{TTable}{C}{$x$}{$f(x)$}
\TRow{ }{0}{0}
\TRow{ }{1}{1}
\end{TTable}
\end{center}
\BigSkip{}
\visible<2->{%
\begin{center}
\begin{UTable}{$U_C$}{$x$}{$y$}{$f(x)$}{$x$}{\Xor{y}{f(x)}}
\URow{}{0}{0}{0}{0}{0}
\URow{}{0}{1}{0}{0}{1}
\URow{}{1}{0}{1}{1}{1}
\URow{}{1}{1}{1}{1}{0}
\end{UTable}\end{center}}
}{%
\begin{Oracle}[scale=0.75]{$U_C$}{$x$}{$y$}{$x$}{\Xor{y}{f(x)}}
\end{Oracle}

\BigSkip{}
\visible<3->{%
\Forall{x}{f(x)=x}, so $\Xor{y}{f(x)}=\Xor{y}{x}$.}%

\BigSkip{}
\only<3>{%
The matrix form may look familiar?
\[U_{C} = \CNOTMatrix{} \]
}%
\only<4>{%
Thus, a \NamedGate{CNOT} gate will flip $y$ when $x$ is~$1$:
\begin{center}
\adjustbox{valign=t}{\begin{quantikz}
\lstick{\ket{x}} &  \ctrl{1} & \qw \rstick{\ket{x}} \\
\lstick{\ket{y}} &  \targ{} & \qw \rstick{\ket{\Xor{y}{f(x)}}}
\end{quantikz}}\end{center}
}
}
    
\end{frame}

\begin{frame}{Realizing the oracle for \Quote{D}: $f(x)=\Not{x}$}{We design a circuit that meets the classical specification.}

\TwoColumns{%
\Vskip{-3em}\begin{center}
\begin{TTable}{D}{$x$}{$f(x)$}
\TRow{ }{0}{1}
\TRow{ }{1}{0}
\end{TTable}
\end{center}
\BigSkip{}
\visible<2->{%
\begin{center}
\begin{UTable}{$U_D$}{$x$}{$y$}{$f(x)$}{$x$}{\Xor{y}{f(x)}}
\URow{}{0}{0}{1}{0}{1}
\URow{}{0}{1}{1}{0}{0}
\URow{}{1}{0}{0}{1}{0}
\URow{}{1}{1}{0}{1}{1}
\end{UTable}\end{center}}
}{%
\begin{Oracle}[scale=0.75]{$U_D$}{$x$}{$y$}{$x$}{\Xor{y}{f(x)}}
\end{Oracle}

\BigSkip{}
\visible<3->{%
\Forall{x}{f(x)=\Not{x}}, so $\Xor{y}{f(x)}=\Xor{y}{\Not{x}}=\Not{\Xor{y}{x}}$.}%

\BigSkip{}
\only<3>{%
This just like the previous case, except the output is the complement of what we had before.
}%
\only<4>{%
Thus, we add an \PauliX{} gate after the \NamedGate{CNOT} gate:
\begin{center}
\adjustbox{valign=t}{\begin{quantikz}
\lstick{\ket{x}} &  \ctrl{1} & \qw & \qw \rstick{\ket{x}} \\
\lstick{\ket{y}} &  \targ{} & \gate{X} & \qw \rstick{\ket{\Xor{y}{f(x)}}}
\end{quantikz}}\end{center}
}
}
    
\end{frame}
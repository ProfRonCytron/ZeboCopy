\SetTitle{21}{Deutsch's Problem}{Is $f(x)$ constant or balanced?}{20}

\begin{frame}{Deutsch's problem}{Formulation}

\begin{itemize}
    \item We are given an oracle $f(x): \Set{0,1} \mapsto \Set{0,1}$
    \item We can characterize $f(x)$ as follows:
    \begin{description}
        \item[constant]   \Forall{x}{f(x)=k}, where $k$ is $0$ or $1$
        \item[balanced]   For half of its inputs, $f(x)=1$ and for the other half $f(x)=0$
    \end{description}
    \item Given the domain and range of $f(x)$, the function must be one of the above.
\end{itemize}
    
\end{frame}

\begin{frame}{Possible functions}{There are only four.}

\TwoColumns{%
\visible<2->{\begin{center}\alert{Constant}\end{center}}
\SBitTable{A}{0}{0}{1}{0}
\SBitTable{B}{0}{1}{1}{1}
}{%
\visible<3>{\begin{center}\alert{Balanced}\end{center}}
\SBitTable{C}{0}{0}{1}{1}
\SBitTable{D}{0}{1}{1}{1}
}
    
\end{frame}

\begin{frame}{Form of the oracle}{It has to be reversible.}
\TwoUnequalColumns{0.6\textwidth}{0.4\textwidth}{%
\begin{itemize}[<+->]
    \item We consider a quantum gate $U_f$ that implements $f(x)$.
    \item It accepts $x$ and an \href{https://en.wikipedia.org/wiki/Ancilla_bit}{ancillary} input $y$.
    \item It copies $x$ onto the top output qubit.
    \item It computes \Xor{y}{f(x)} on the bottom output qubit.
    \item When $y=\ket{0}$ the bottom qubit is $f(x)$.
    \item When $y=\ket{1}$ the bottom qubit is \Not{$f(x)$}.
\end{itemize}
}{%
\BigSkip{}
\only<1>{%
\begin{Oracle}[scale=0.75]{$U_f$}{\relax}{\relax}{\relax}{\relax}
\end{Oracle}}%
\only<2>{%
\begin{Oracle}[scale=0.75]{$U_f$}{$x$}{$y$}{\relax}{\relax}
\end{Oracle}}%
\only<3>{%
\begin{Oracle}[scale=0.75]{$U_f$}{$x$}{$y$}{$x$}{\relax}
\end{Oracle}}%
\only<4>{%
\begin{Oracle}[scale=0.75]{$U_f$}{$x$}{$y$}{$x$}{\Xor{y}{f(x)}}
\end{Oracle}}%
\only<5>{%
\begin{Oracle}[scale=0.75]{$U_f$}{$x$}{\ket{0}}{$x$}{$f(x)$}
\end{Oracle}}%
\only<6>{%
\begin{Oracle}[scale=0.75]{$U_f$}{$x$}{\ket{1}}{$x$}{\Not{$f(x)$}}
\end{Oracle}}%
}    
\end{frame}



\begin{frame}{Realizing the oracle for \Quote{A}: $f(x)=0$}{We design a circuit that meets the classical specification.}

\TwoColumns{%
\Vskip{-3em}\begin{center}
\begin{TTable}{A}{$x$}{$f(x)$}
\TRow{ }{0}{0}
\TRow{ }{1}{0}
\end{TTable}
\end{center}
\BigSkip{}
\visible<2->{%
\begin{center}
\begin{UTable}{$U_A$}{$x$}{$y$}{$f(x)$}{$x$}{\Xor{y}{f(x)}}
\URow{}{0}{0}{0}{0}{0}
\URow{}{0}{1}{0}{0}{1}
\URow{}{1}{0}{0}{1}{0}
\URow{}{1}{1}{0}{1}{1}
\end{UTable}\end{center}}
}{%
\begin{Oracle}[scale=0.75]{$U_A$}{$x$}{$y$}{$x$}{\Xor{y}{f(x)}}
\end{Oracle}

\BigSkip{}
\visible<3->{%
\Forall{x}{f(x)=0}, so $\Xor{y}{f(x)}=\Xor{y}{0}=y$.  
\MedSkip{}
Thus, $U_A$ is just the identity function, so our quantum circuit doesn't have to do anything to its inputs to realize $U_A$.}

\BigSkip{}
\visible<4>{%
\begin{center}
\adjustbox{valign=t}{\begin{quantikz}
\lstick{\ket{x}} &  \qw & \qw \rstick{\ket{x}} \\
\lstick{\ket{y}} &  \qw & \qw \rstick{\ket{\Xor{y}{f(x)}}}
\end{quantikz}}\end{center}
}
}
    
\end{frame}

\begin{frame}{Realizing the oracle for \Quote{B}: $f(x)=1$}{We design a circuit that meets the classical specification.}

\TwoColumns{%
\Vskip{-3em}\begin{center}
\begin{TTable}{B}{$x$}{$f(x)$}
\TRow{ }{0}{1}
\TRow{ }{1}{1}
\end{TTable}
\end{center}
\BigSkip{}
\visible<2->{%
\begin{center}
\begin{UTable}{$U_B$}{$x$}{$y$}{$f(x)$}{$x$}{\Xor{y}{f(x)}}
\URow{}{0}{0}{1}{0}{1}
\URow{}{0}{1}{1}{0}{0}
\URow{}{1}{0}{1}{1}{1}
\URow{}{1}{1}{1}{1}{0}
\end{UTable}\end{center}}
}{%
\begin{Oracle}[scale=0.75]{$U_B$}{$x$}{$y$}{$x$}{\Xor{y}{f(x)}}
\end{Oracle}

\BigSkip{}
\visible<3->{%
\Forall{x}{f(x)=1}, so $\Xor{y}{f(x)}=\Xor{y}{1}=\Not{y}$.  
\MedSkip{}
Thus, $U_B$ is realized by complementing $y$.}

\BigSkip{}
\visible<4>{%
\begin{center}
\adjustbox{valign=t}{\begin{quantikz}
\lstick{\ket{x}} &  \qw & \qw \rstick{\ket{x}} \\
\lstick{\ket{y}} &  \gate{X} & \qw \rstick{\ket{\Xor{y}{f(x)}}}
\end{quantikz}}\end{center}
}
}
    
\end{frame}

\begin{frame}{Realizing the oracle for \Quote{C}: $f(x)=x$}{We design a circuit that meets the classical specification.}

\TwoColumns{%
\Vskip{-3em}\begin{center}
\begin{TTable}{C}{$x$}{$f(x)$}
\TRow{ }{0}{0}
\TRow{ }{1}{1}
\end{TTable}
\end{center}
\BigSkip{}
\visible<2->{%
\begin{center}
\begin{UTable}{$U_C$}{$x$}{$y$}{$f(x)$}{$x$}{\Xor{y}{f(x)}}
\URow{}{0}{0}{0}{0}{0}
\URow{}{0}{1}{0}{0}{1}
\URow{}{1}{0}{1}{1}{1}
\URow{}{1}{1}{1}{1}{0}
\end{UTable}\end{center}}
}{%
\begin{Oracle}[scale=0.75]{$U_C$}{$x$}{$y$}{$x$}{\Xor{y}{f(x)}}
\end{Oracle}

\BigSkip{}
\visible<3->{%
\Forall{x}{f(x)=x}, so $\Xor{y}{f(x)}=\Xor{y}{x}$.}%

\BigSkip{}
\only<3>{%
The matrix form may look familiar?
\[U_{C} = \CNOTMatrix{} \]
}%
\only<4>{%
Thus, a \NamedGate{CNOT} gate will flip $y$ when $x$ is~$1$:
\begin{center}
\adjustbox{valign=t}{\begin{quantikz}
\lstick{\ket{x}} &  \ctrl{1} & \qw \rstick{\ket{x}} \\
\lstick{\ket{y}} &  \targ{} & \qw \rstick{\ket{\Xor{y}{f(x)}}}
\end{quantikz}}\end{center}
}
}
    
\end{frame}

\begin{frame}{Realizing the oracle for \Quote{D}: $f(x)=\Not{x}$}{We design a circuit that meets the classical specification.}

\TwoColumns{%
\Vskip{-3em}\begin{center}
\begin{TTable}{D}{$x$}{$f(x)$}
\TRow{ }{0}{1}
\TRow{ }{1}{0}
\end{TTable}
\end{center}
\BigSkip{}
\visible<2->{%
\begin{center}
\begin{UTable}{$U_D$}{$x$}{$y$}{$f(x)$}{$x$}{\Xor{y}{f(x)}}
\URow{}{0}{0}{1}{0}{1}
\URow{}{0}{1}{1}{0}{0}
\URow{}{1}{0}{0}{1}{0}
\URow{}{1}{1}{0}{1}{1}
\end{UTable}\end{center}}
}{%
\begin{Oracle}[scale=0.75]{$U_D$}{$x$}{$y$}{$x$}{\Xor{y}{f(x)}}
\end{Oracle}

\BigSkip{}
\visible<3->{%
\Forall{x}{f(x)=\Not{x}}, so $\Xor{y}{f(x)}=\Xor{y}{\Not{x}}=\Not{\Xor{y}{x}}$.}%

\BigSkip{}
\only<3>{%
This just like the previous case, except the output is the complement of what we had before.
}%
\only<4>{%
Thus, we add an \PauliX{} gate after the \NamedGate{CNOT} gate:
\begin{center}
\adjustbox{valign=t}{\begin{quantikz}
\lstick{\ket{x}} &  \ctrl{1} & \qw & \qw \rstick{\ket{x}} \\
\lstick{\ket{y}} &  \targ{} & \gate{X} & \qw \rstick{\ket{\Xor{y}{f(x)}}}
\end{quantikz}}\end{center}
}
}
    
\end{frame}

\begin{frame}{Is $f(x)$ constant or balanced?}{Classical approach}

\TwoColumns{%
\begin{itemize}[<+->]
    \item If we perform one evaluation of $f$, say on $0$, then we do not know if $f(x)$ is always $f(0)$ or if $f(x)$ may be different.
    \item Classically it takes \emph{two} queries of $f$ to determine the answer to this question.
\end{itemize}
}{%
\begin{align*}
    f(0) &= 0 \\
    f(1) &= \ ?
\end{align*}
}
\BigSkip{}
\visible<3>{We will see that a quantum circuit for $f$ can reveal whether the function is constant or balanced with \emph{a single} query!}
\end{frame}

\begin{frame}{Solution}{We can arrange for the quantum circuit to produce all possible answers.}

\begin{center}
\begin{GateBox}[scale=1.0]{2}{1.2}{2}
\BoxLabel{$Q_f$}
\Input{0}{\alt<1>{\QPlus{}}{\ket{+}}}
\Input{1}{\ket{0}}
\ComputeMyY{0}\draw (0,\MyY) node[right] {$x$};
\ComputeMyY{1}\draw (0,\MyY) node[right] {$y$};
\Output{0}{$x$}
\Output{1}{\Xor{y}{f(x)}}
\end{GateBox}
\end{center}
\TwoColumns{%
\begin{itemize}
    \item<1-> The input is the superposition of the two possible basis states.
    \item<2-> We know this state as \ket{+}.
    \item<3-> Recall we can create $\ket{+}=\QPlus{}$ using this circuit:
\end{itemize}
}{%
\visible<3->{%
\begin{center}
\adjustbox{valign=t}{\begin{quantikz}
\lstick{\ket{0}} &  \gate{H} &  \qw \rstick{\ket{+}}
\end{quantikz}}%
\end{center}}
}
    
\end{frame}
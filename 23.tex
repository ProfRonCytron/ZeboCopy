\SetTitle{23}{The Deutsch-Josza problem}{Demonstrates asymptotic quantum advantage}{23}

\begin{frame}{Overview}{What will we study here?}

\begin{itemize}[<+->]
    \item This problem and its solution are due to
    \href{https://en.wikipedia.org/wiki/David_Deutsch}{David Deutsch} and \href{https://en.wikipedia.org/wiki/Richard_Jozsa}{Richard Josza}.
    \item This problem is similar to Deutsch's problem, which we have studied.
    \item But here, $f(x)$ takes an input of $n$~bits.
    \item We care, as before, whether $f(x)$ is \emph{constant} or \emph{balanced}.
    \item This problem distinguishes the complexity classes
    \begin{description}
        \item[\href{https://complexityzoo.net/Complexity_Zoo:P}{\CompClass{P}}] problems that can be solved in polynomial time on a quantum computer
        \item[\href{https://complexityzoo.net/Complexity_Zoo:E\#eqp}{\CompClass{EQP}}] problems that can be solved \textbf{e}xactly on a \textbf{q}uantum computer in \textbf{p}olynomial time.
    \end{description}
    \item The phase-kickback trick we have just studied is the key to solving this problem efficiently on a quantum computer.
\end{itemize}
    
\end{frame}

\begin{frame}{Exact}{What's up with that?}
\begin{itemize}[<+->]
    \item There are two sources of inaccuracy in quantum computing:
    \begin{itemize}
        \item Some algorithms are inherently probabilistic, such as the Elitzur--Vaidman bomb we have studied. While you are likely to get a desired result, it may take effort to overcome the probability of obtaining the wrong answer.  And you may be unlucky to the point where it takes a long time to get the answer.
        \item Quantum computing devices are subject to noise and other interference that causes \href{https://en.wikipedia.org/wiki/Quantum_decoherence}{decoherence}.  Results from a system experiencing decoherence are unpredictable and invalid.
    \end{itemize}
    \item Simulation (emulation) provides results with no artifacts of decoherence, but those are restrictive in the number of quantum bits (\href{https://qiskit.org/documentation/tutorials/simulators/6_extended_stabilizer_tutorial.html}{currently}, 63) that can be accommodated in reasonable time.
    \item So, \emph{exact quantum polynomial} means that on an ideal quantum device, we obtain the answer exactly, with probability 100\%, in polynomial time.
\end{itemize}
\end{frame}

\begin{frame}{On the pronunciation of Josza}{From the author himself}

Thanks for your interesting question!  I generally pronounce my surname as~\Quote{joe--zuh}.
\SmallSkip{}
But this is an anglicised version---the name is Hungarian and the correct Hungarian pronunciation is  \Quote{your--zho} with \emph{zh} pronounced as the \emph{s} in \emph{pleasure} and \emph{o} as the \emph{o} in \emph{hot}.
\SmallSkip{}
I hope that gives enough of an indication, and I wish you and your students all the best for your QC course!
\BigSkip{}
Best wishes,  Richard.
\end{frame}

\begin{frame}{Deutsch--Josza}{Problem statement}
\begin{itemize}[<+->]
    \item We are given a function $f(x): \Set{0,1}^{n}\mapsto \Set{0,1}$.  It takes in a value expressed in $n$ bits and returns \True{} or \False{}.
    \item We are \href{https://en.wikipedia.org/wiki/Promise_problem}{promised} that $f(x)$ is one of the following:
    \begin{description}
        \item[constant]  \Forall{x\in \Set{0,1}^n}{f(x) = k}, where $k=0$ or $k=1$.
        \item[balanced]  For exactly half of its inputs, $f(x) = 0$ and for the other half $f(x) = 1$.
    \end{description}
\end{itemize}
\end{frame}

\begin{frame}{Sneak preview}{Of the secret sauce}
\Vskip{-3.5em}\begin{itemize}[<+->]
    \item The function $f(x)$ accepts an input \AllBits{x}{n}.  Each input is $n$~bits long, and \alert<10->{there are $2^n$ such strings} in the domain.
    \item For each such $x$, $f(x)$ evaluates to~$0$ or~$1$.  \only<10->{\alert{Then \NegF{x} is $\pm 1$.}}
    \item If we compute $\SumBV{x}{n} \alt<9->{\alert{\NegF{x}}}{f(x)}$ then we should obtain:
    \begin{description}
        \item[\alt<11->{\alert{$2^n$}}{$0$}]  We obtain this sum if \Forall{x}{f(x)=0}.
        \item[\alt<12->{\alert{$-2^{n}$}}{$2^n$}]  We obtain this sum if \Forall{x}{f(x)=1}.
        \item[\alt<13->{\alert{$0$}}{$\frac{2^n}{2}=2^{n-1}$}]  \textcolor<14->{\RCtwo}{We obtain this sum if exactly half of the function evaluations are~$1$ and the other half are~$0$.}
    \end{description}
    \item As described, we require $2^n$ function evaluations classically.  We hope to use a quantum computer to accomplish that work with a single evaluation.
    \item But first we are going to make \alert{one change} to our summation to leverage \textcolor<14->{\RCtwo}{interference} in quantum systems.
\end{itemize}
    
\end{frame}

\begin{frame}{Deutsch--Josza solution}{Compared to the Deutsch circuit}

\TwoUnequalColumns{0.55\textwidth}{0.45\textwidth}{%
\begin{center}
\Vskip{-3em}\adjustbox{valign=t, width=\textwidth}{\begin{quantikz}
\lstick{\ket{\TensSupProd{0}{n}}} & \qwbundle{\alert<1>{n}}\slice{\QState{0}} &  \gate{\alert<3>{\TensSupProd{\Hadamard}{n}}}\slice{\QState{1}} & \gate[wires=2][5em]{\mbox{$U_f$}}\gateinput{$x$}\gateoutput{$x$}\slice{\QState{2}} &\gate{\alert<3>{\TensSupProd{\Hadamard}{n}}}\slice{\QState{3}} & \meter{0/1} \\
\lstick{\alert<2>{\QZero{}}} & \gate{\alert<2>{\PauliX}} &   \gate{\alert<2>{\Hadamard}}   &  \qw\gateinput{$y$}\gateoutput{\Xor{y}{f(x)}} & \qw & \qw
\end{quantikz}} \only<1-3>{\\[1em]
Deutsch--Josza Problem, $n$ qubits}
\end{center}
}{%
\only<1-3>{%
\begin{center}
\Vskip{-3em}\adjustbox{valign=t, width=\textwidth}{\begin{quantikz}
\lstick{\QZero{}} & \qw\slice{\QState{0}} &  \gate{\Hadamard}\slice{\QState{1}} & \gate[wires=2][5em]{\mbox{$U_f$}}\gateinput{$x$}\gateoutput{$x$}\slice{\QState{2}} &\gate{\Hadamard}\slice{\QState{3}} & \meter{0/1} \\
\lstick{\QZero{}} & \gate{\PauliX} &   \gate{\Hadamard}   &  \qw\gateinput{$y$}\gateoutput{\Xor{y}{f(x)}} & \qw & \qw
\end{quantikz}} \only<1-3>{\\[1.2em]
Deutsch Problem, single qubit}
\end{center}%
}%
}
\only<1-3>{%
\BigSkip{}
\begin{itemize}
    \item<1-> The Deutsch--Josza input for $x$ is now $n$ qubits.
    \item<2-> The input for $y$ is still a single qubit, whose value will be \ket{-} going into $U_f$.
    \item<3-> We apply an $n$-way Hadamard operation on either side of $U_f$ to the top $n$~qubits~($x$).  This is realized by a single Hadamard gate applied to each qubit for $x$.
\end{itemize}
}

    
\end{frame}

\begin{frame}{Deutsch--Josza Solution}{Up to \QState{2}, prior to the final \TensSupProd{\Hadamard}{n}}
\only<4-24,32->{%
\Vskip{-4em}\TwoUnequalColumns{0.51\textwidth}{0.49\textwidth}{%
\begin{center}
\Vskip{-3em}\adjustbox{valign=t, width=\textwidth}{\begin{quantikz}
\lstick{\ket{\textcolor<8->{\RCone}{\TensSupProd{0}{n}}}} & \qwbundle{\alert<1>{n}}\slice{\alert<8>{\QState{0}}} &  \gate{\alert<5>{\TensSupProd{\Hadamard}{n}}}\slice{\alert<9-10>{\QState{1}}} & \gate[wires=2][5em]{\mbox{$U_f$}}\gateinput{$x$}\gateoutput{$x$}\slice{\alert<11>{\QState{2}}} &\gate{\alert<6,11>{\TensSupProd{\Hadamard}{n}}}\slice{\alert<12->{\QState{3}}} & \meter{0/1} \\
\lstick{\textcolor<8->{\RCtwo}{\QZero{}}} & \gate{\textcolor<8->{\RCtwo}{\PauliX}} &   \gate{\Hadamard}   &  \qw\gateinput{$y$}\gateoutput{\Xor{y}{f(x)}} & \qw & \qw
\end{quantikz}} \only<1-3>{\\[1em]
Deutsch--Josza Problem, $n$ qubits}
\end{center}
\only<11>{%
\BigSkip{}
This is the phase-kickback trick result.  But how do we compute The \alert{\TensSupProd{\Hadamard}{n}} when its input is something other than \TensSupProd{0}{n}?}
}{%
\only<8-24>{%
\Vskip{-2.5em}\begin{align*}
   \only<8-10>{ \QState{0} &= \ket{\ColorOne{\TensSupProd{0}{n}}\,\ColorTwo{1}} \\}
   \only<8-11>{%
   \visible<9->{ \QState{1} &= \TensSupProd{\Hadamard}{n+1} \QState{0} \\}
    \visible<10-> {& =  \ColorOne{\RootTwoN{n}}\TensProd{\ColorOne{\SumBV{w}{n}\ket{w}}}{\ColorTwo{\ket{-}}} \\}}
    \only<11-13>{%
    \visible<11->{\QState{2} &= \ColorOne{\RootTwoN{n}}\TensProd{\ColorOne{\SumBV{w}{n} \NegF{w}\ket{w}}}{\ColorTwo{\ket{-}}} \\}
    \visible<12->{\QState{3} &= \left(\TensProd{\TensSupProd{\Hadamard}{n}}{\Identity}\right)(\QState{2}) \\}}
    \visible<13->{%
       \only<14->{\QState{3}} & = \frac{\TensSupProd{\Hadamard}{n}
       (
       \ColorOne{\SumBV{w}{n} \NegF{w}\ket{w}}
       )}{\ColorOne{\sqrt{2^n}}} \\
       & \TensOp{} \ColorTwo{\only<13>{\Identity}\ket{-}}
    }
\end{align*}
}%
\only<32->{%
\begin{itemize}
    \item<32-> If we measure \TensSupProd{0}{n} only, then $f(x)$ is constant.
    \item<33-> Otherwise we should never see \TensSupProd{0}{n} and $f(x)$ is balanced.
    \item<34-> What if \TensSupProd{0}{n} seen sometimes?
\end{itemize}
\MedSkip{}
}
}}%
\only<4-7>{%
\begin{itemize}
    \item<4-> We have seen
    \Vskip{-3em}\[ \TensSupProd{\Hadamard}{n}\ket{\TensSupProd{0}{n}} = 
    \RootTwoN{n}\SumBV{w}{n} \ket{w} = \RootTwoN{n}\DQB{1}{\vdots}{\vdots}{1}
    \]
    \item<5-> So we know the result of these $n$ \Hadamard{} operations.
    \item<6-> But what about these?  Their input is probably not \ket{\TensSupProd{0}{n}}, so we need to analyze what happens there.
    \item<7-> We present results first and proofs later.
\end{itemize}
}%
\only<14-16>{%
\BigSkip{}
\begin{itemize}
\item<14-> How do we compute \TensSupProd{\Hadamard}{n}(\ket{w}), where \ket{w} is a basis state, but not necessarily~\ket{\TensSupProd{0}{n}}?  
\item<15-> We show how to do this here, leaving the proof for later.
\item<16-> It suffices to study basis states, as linearity applies to \ColorOne{superpositions}.
\end{itemize}
}%
\only<17-20>{%
\TwoColumns{%
\Vskip{-2.5em}\begin{center}
\begin{TIKZP}[scale=0.9]
\draw (0,0) rectangle ++(0.5,0.8) node[pos=0.5] {$v_1$};
\draw (0.5,0) rectangle ++(0.5,0.8) node[pos=0.5] {$v_2$};
\draw (1,0) rectangle ++(0.5,0.8) node[pos=0.5] {$\cdot$};
\draw (1.5,0) rectangle ++(0.5,0.8) node[pos=0.5] {$\cdot$};
\draw (2,0) rectangle ++(0.5,0.8) node[pos=0.5] {$\cdot$};
\draw (2.5,0) rectangle ++(0.5,0.8) node[pos=0.5] {$v_n$};
\draw (0,-1.2) rectangle ++(0.5,0.8) node[pos=0.5] {$w_1$};
\draw (0.5,-1.2) rectangle ++(0.5,0.8) node[pos=0.5] {$w_2$};
\draw (1,-1.2) rectangle ++(0.5,0.8) node[pos=0.5] {$\cdot$};
\draw (1.5,-1.2) rectangle ++(0.5,0.8) node[pos=0.5] {$\cdot$};
\draw (2,-1.2) rectangle ++(0.5,0.8) node[pos=0.5] {$\cdot$};
\draw (2.5,-1.2) rectangle ++(0.5,0.8) node[pos=0.5] {$w_n$};
\end{TIKZP}\end{center}
\begin{itemize}
    \item<18-> \ColorThree{This is the exclusive-or of the \emph{and} of each pair of bits.}
    \item<19-> \ColorFour{This is the sum of the product of each pair of bits.}
\end{itemize}
}{%
\SmallSkip{}
We define the operation \DotP{v}{w} on two $n$-bit vectors $v$ and $w$ as follows:
\begin{align*}
   \visible<18->{ \DotP{v}{w} & \ColorThree{= \oplus_{i=1}^{n}\ {v_i}{w_i}} \\}
        \visible<19->{ & \ColorFour{= \sum_{i=1}^{n}\ {v_i}{w_i}\ \mbox{(mod 2)}}}
\end{align*}
\only<20->{\Vskip{-1em}These are equivalent (proof later).}
}}%
\only<21-26>{%
\[
P(n):  \TensSupProd{\Hadamard}{n}\ket{w}
  = \textcolor<26>{\RCthree}{\RootTwoN{n}\SumBV{v}{n} \NegOneExp{\DotP{v}{w}} \ket{v}}
\]}%
\only<21-23>{%
\begin{itemize}
\item<22-> \TensSupProd{\Hadamard}{n}\ket{\TensSupProd{0}{n}} provides the correct result, because \Implies{w=0^n}{\Forall{v}{\DotP{v}{w}=0}}.
\item<23-> We can use this formula to compute \QState{3}.
\end{itemize}}
\only<24-31>{%
\Vskip{-2em}\begin{align*}
\only<24-26>{%
    \visible<24->{\ColorOne{\sqrt{2^n}} \QState{3} &= \TensProd{\TensSupProd{\Hadamard}{n}
       (
       \ColorOne{\SumBV{w}{n} \NegF{w}\ket{w}}
       )}{\ColorTwo{\ket{-}}} \\}
    \visible<25->{   &= \TensProd{\ColorOne{\SumBV{w}{n} \NegF{w}} \TensSupProd{\Hadamard}{n}(\ColorOne{\ket{w}})}{\ColorTwo{\ket{-}}} \\}}
    \only<26-28>{\visible<26->{
    \ColorThree{\sqrt{2^n}}\ColorOne{\sqrt{2^n}}\QState{3} &= \TensProd{\ColorOne{\SumBV{w}{n} \NegF{w}}\ColorThree{\SumBV{v}{n} \NegOneExp{\DotP{v}{w}} \ket{v}}}{\ColorTwo{\ket{-}}} \\
    }}%
    \visible<28->{%
    \only<29->{\ColorThree{\sqrt{2^n}}\ColorOne{\sqrt{2^n}}\QState{3}}&= \TensProd{\ColorThree{\SumBV{v}{n}} \ColorOne{\SumBV{w}{n}} \ColorOne{\NegF{w}} \ColorThree{\NegOneExp{\DotP{v}{w}}} \ColorThree{\ket{v}}}{\ColorTwo{\ket{-}}}
    }
\end{align*}
}%
\only<29->{%
Look at the $\ColorThree{\ket{v}}=\ket{\TensSupProd{0}{n}}$ term, where \Forall{\ColorThree{v}}{\ColorThree{\NegOneExp{\DotP{v}{w}}}=1}
    \begin{description}
      \item<30->[\Forall{w}{\ColorOne{f(w)}=0}:]  $\ColorOne{\SumBV{w}{n} 1}\ =\ {2^n}$. All other \ColorThree{\ket{v}} terms have zero amplitude.
      \item<31->[\Forall{w}{\ColorOne{f(w)}=1}:] $\ColorOne{\SumBV{w}{n} -1}\ =\ -{2^n}$. All other \ColorThree{\ket{v}} terms have zero amplitude.
      \item<31->[\ColorOne{$f(w)$} balanced:]
      \Vskip{-2em}\[
      \ColorOne{\SumBV{w}{n} \NegOneExp{f(w)}}
      = 2^{n-1} - 2^{n-1}
      = 0
      \]
    \end{description}
}
\end{frame}

\section*{Proofs}

\begin{frame}{Proof}{Hadamard on non-zero states}
    
\end{frame}

\begin{frame}{Proof}{about dot products}
    
\end{frame}
    

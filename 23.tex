\SetTitle{23}{The Deutsch-Josza problem}{Demonstrates asymptotic quantum advantage}{23}

\begin{frame}{Overview}{What will we study here?}

\begin{itemize}[<+->]
    \item This problem and its solution are due to
    \href{https://en.wikipedia.org/wiki/David_Deutsch}{David Deutsch} and \href{https://en.wikipedia.org/wiki/Richard_Jozsa}{Richard Josza}.
    \item This problem is similar to Deutsch's problem, which we have studied.
    \item But here, $f(x)$ takes an input of $n$~bits.
    \item We care, as before, whether $f(x)$ is \emph{constant} or \emph{balanced}.
    \item This problem distinguishes the complexity classes
    \begin{description}
        \item[\href{https://complexityzoo.net/Complexity_Zoo:P}{\CompClass{P}}] problems that can be solved in polynomial time on a quantum computer
        \item[\href{https://complexityzoo.net/Complexity_Zoo:E\#eqp}{\CompClass{EQP}}] problems that can be solved \textbf{e}xactly on a \textbf{q}uantum computer in \textbf{p}olynomial time.
    \end{description}
    \item The phase-kickback trick we have just studied is the key to solving this problem efficiently on a quantum computer.
\end{itemize}
    
\end{frame}

\begin{frame}{Exact}{What's up with that?}
\begin{itemize}[<+->]
    \item There are two sources of inaccuracy in quantum computing:
    \begin{itemize}
        \item Some algorithms are inherently probabilistic, such as the Elitzur--Vaidman bomb we have studied. While you are likely to get a desired result, it may take effort to overcome the probability of obtaining the wrong answer, and it is possible though very unlikely that you cannot obtain the answer.
        \item Quantum computing devices are subject to noise and other interference that causes \href{https://en.wikipedia.org/wiki/Quantum_decoherence}{decoherence}.  Results from a system experiencing decoherence are unpredictable and invalid.
    \end{itemize}
    \item Simulation (emulation) provides results with no artifacts of decoherence, but those are restrictive in the number of quantum bits (\href{https://qiskit.org/documentation/tutorials/simulators/6_extended_stabilizer_tutorial.html}{currently}, 63) that can be accommodated in reasonable time.
    \item So, \emph{exact quantum polynomial} means that on an ideal quantum device, we obtain the answer exactly, with probability 100\%, in polynomial time.
\end{itemize}
\end{frame}

\begin{frame}{Deutsch-Josza}{Problem statement}
\begin{itemize}[<+->]
    \item We are given a function $f(x): \Set{0,1}^{n}\mapsto \Set{0,1}$
    \item We are \href{https://en.wikipedia.org/wiki/Promise_problem}{promised} that $f(x)$ is one of the following:
    \begin{description}
        \item[constant]  \Forall{x\in \Set{0,1}^n}{f(x) = k}, where $k=0$ or $k=1$.
        \item[balanced]  For exactly half of its inputs, $f(x) = 0$ and for the other half $f(x) = 1$.
    \end{description}
    \item 
\end{itemize}
\end{frame}

\begin{frame}{Solution}{Like before}
\Vskip{-4em}\TwoUnequalColumns{0.52\textwidth}{0.48\textwidth}{%
\begin{center}
\Vskip{-3em}\adjustbox{valign=t, width=\textwidth}{\begin{quantikz}
\lstick{\ket{\textcolor<8->{\RCone}{\TensSupProd{0}{n}}}} & \qwbundle{\alert<1>{n}}\slice{\alert<8>{\QState{0}}} &  \gate{\alert<3,5>{\TensSupProd{\Hadamard}{n}}}\slice{\alert<9-10>{\QState{1}}} & \gate[wires=2][5em]{\mbox{$U_f$}}\gateinput{$x$}\gateoutput{$x$}\slice{\alert<11>{\QState{2}}} &\gate{\alert<3,6,11>{\TensSupProd{\Hadamard}{n}}}\slice{\alert<12->{\QState{3}}} & \meter{0/1} \\
\lstick{\alert<2>{\textcolor<8->{\RCtwo}{\QZero{}}}} & \gate{\alert<2>{\textcolor<8->{\RCtwo}{\PauliX}}} &   \gate{\alert<2>{\Hadamard}}   &  \qw\gateinput{$y$}\gateoutput{\Xor{y}{f(x)}} & \qw & \qw
\end{quantikz}} \only<1-3>{\\[1em]
Deutsch-Josza Problem, $n$ qubits}
\end{center}
\only<11>{%
\BigSkip{}
This is the phase-kickback trick result.  But how do we compute The \alert{\TensSupProd{\Hadamard}{n}} when its input is something other than \TensSupProd{0}{n}?}
}{%
\only<1-3>{%
\begin{center}
\Vskip{-3em}\adjustbox{valign=t, width=\textwidth}{\begin{quantikz}
\lstick{\QZero{}} & \qw\slice{\QState{0}} &  \gate{\Hadamard}\slice{\QState{1}} & \gate[wires=2][5em]{\mbox{$U_f$}}\gateinput{$x$}\gateoutput{$x$}\slice{\QState{2}} &\gate{\Hadamard}\slice{\QState{3}} & \meter{0/1} \\
\lstick{\QZero{}} & \gate{\PauliX} &   \gate{\Hadamard}   &  \qw\gateinput{$y$}\gateoutput{\Xor{y}{f(x)}} & \qw & \qw
\end{quantikz}} \only<1-3>{\\[1em]
Deutsch Problem, single qubit}
\end{center}%
}%
\only<8->{%
\Vskip{-2.5em}\begin{align*}
   \only<8-10>{ \QState{0} &= \ket{\ColorOne{\TensSupProd{0}{n}}\,\ColorTwo{1}} \\}
   \only<8-11>{%
   \visible<9->{ \QState{1} &= \TensSupProd{\Hadamard}{n+1} \QState{0} \\}
    \visible<10-> {& =  \ColorOne{\RootTwoN{n}}\TensProd{\ColorOne{\SumBV{x}{n}\ket{x}}}{\ColorTwo{\ket{-}}} \\}}
    \only<11-13>{%
    \visible<11->{\QState{2} &= \ColorOne{\RootTwoN{n}}\TensProd{\ColorOne{\SumBV{x}{n} \NegF{x}\ket{x}}}{\ColorTwo{\ket{-}}} \\}
    \visible<12->{\QState{3} &= \left(\TensProd{\TensSupProd{\Hadamard}{n}}{\Identity}\right)(\QState{2}) \\}}
    \visible<13->{%
       \only<14->{\QState{3}} & = \frac{\TensSupProd{\Hadamard}{n}
       \left(
       \ColorOne{\SumBV{x}{n} \NegF{x}\ket{x}}
       \right)}{\ColorOne{\sqrt{2^n}}} \\
       & \TensOp{} \ColorTwo{\only<13>{\Identity}\ket{-}}
    }
\end{align*}
}%
}
\only<1-3>{%
\BigSkip{}
\begin{itemize}
    \item<1-> The input for $x$ is now $n$ qubits.
    \item<2-> The input for $y$ is still a single qubit, whose value will be \ket{-} going into $U_f$.
    \item<3-> We apply an $n$-way Hadamard operation on either side of $U_f$ to the top $n$~qubits~($x$).  This is realized by a single Hadamard gate applied to each qubit for $x$.
\end{itemize}
}
\only<4-7>{%
\begin{itemize}
    \item<4-> We have seen
    \Vskip{-3em}\[ \TensSupProd{\Hadamard}{n}\ket{\TensSupProd{0}{n}} = 
    \RootTwoN{n}\SumBV{x}{n} \ket{x} = \RootTwoN{n}\DQB{1}{\vdots}{\vdots}{1}
    \]
    \item<5-> So we know the result of these $n$ \Hadamard{} operations.
    \item<6-> But what about these?  Their input is probably not \ket{\TensSupProd{0}{n}}, so we need to analyze what happens there.
    \item<7-> We accept for now what we are about to see and prove it later.
\end{itemize}
}%
\only<14-16>{%
\BigSkip{}
\begin{itemize}
\item<14-> How do we compute \TensSupProd{\Hadamard}{n}(\ket{w}), where \ket{w} is a basis state, but not necessarily~\ket{\TensSupProd{0}{n}}?  
\item<15-> We show how to this here, leaving the proof for later.
\item<16-> It suffices to study basis states, as linearity applies to \ColorOne{superpositions}.
\end{itemize}
}%
\only<17->{%
\TwoColumns{%
\Vskip{-3em}\begin{center}
\begin{TIKZP}[scale=0.9]
\draw (0,0) rectangle ++(0.5,0.8) node[pos=0.5] {$v_1$};
\draw (0.5,0) rectangle ++(0.5,0.8) node[pos=0.5] {$v_2$};
\draw (1,0) rectangle ++(0.5,0.8) node[pos=0.5] {$\cdot$};
\draw (1.5,0) rectangle ++(0.5,0.8) node[pos=0.5] {$\cdot$};
\draw (2,0) rectangle ++(0.5,0.8) node[pos=0.5] {$\cdot$};
\draw (2.5,0) rectangle ++(0.5,0.8) node[pos=0.5] {$v_n$};
\draw (0,-1.2) rectangle ++(0.5,0.8) node[pos=0.5] {$w_1$};
\draw (0.5,-1.2) rectangle ++(0.5,0.8) node[pos=0.5] {$w_2$};
\draw (1,-1.2) rectangle ++(0.5,0.8) node[pos=0.5] {$\cdot$};
\draw (1.5,-1.2) rectangle ++(0.5,0.8) node[pos=0.5] {$\cdot$};
\draw (2,-1.2) rectangle ++(0.5,0.8) node[pos=0.5] {$\cdot$};
\draw (2.5,-1.2) rectangle ++(0.5,0.8) node[pos=0.5] {$w_n$};
\end{TIKZP}\end{center}
\begin{itemize}
    \item<18-> \ColorThree{This is the exclusive-or of the \emph{and} of each pair of bits.}
    \item<19-> \ColorFour{This is the sum of the product of each pair of bits.}
\end{itemize}
}{%
\SmallSkip{}
We define the operation \DotP{v}{w} on two $n$-bit vectors $v$ and $w$ as follows:
\begin{align*}
   \visible<18->{ \DotP{v}{w} & \ColorThree{= \oplus_{i=1}^{n}\ {v_i}{w_i}} \\}
        \visible<19->{ & \ColorFour{= \sum_{i=1}^{n}\ {v_i}{w_i}\ \mbox{(mod 2)}}}
\end{align*}
\only<20->{\Vskip{-1em}These are equivalent (proof later).}
}}
\end{frame}
    
